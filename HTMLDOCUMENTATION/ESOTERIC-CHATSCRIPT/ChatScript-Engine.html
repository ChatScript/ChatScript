<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="chatscript-engine">ChatScript Engine</h1>
<p>Copyright Bruce Wilcox, gowilcox@gmail.com brilligunderstanding.com<br> <br>Revision 7/18/2021 cs11.5</p>
<ul>
<li><a href="ChatScript-Engine-md#code-zones">Code Zones</a></li>
<li><a href="ChatScript-Engine-md#data">Data</a></li>
<li><a href="ChatScript-Engine-md#memory-management">Memory Management</a></li>
<li><a href="ChatScript-Engine-md#function-run-time-model">Function Run-time Model</a></li>
<li><a href="ChatScript-Engine-md#script-execution">Script Execution</a></li>
<li><a href="ChatScript-Engine-md#rule-tags">Rule Tags</a></li>
<li><a href="ChatScript-Engine-md#concept-representation">Concept Representation</a></li>
<li><a href="#pattern-matching">Pattern Matching</a> (ChatScript-Engine-md#pattern-matching)</li>
<li><a href="ChatScript-Engine-md#supplemental-dictionary-data">Supplemental dictionary data</a></li>
<li><a href="ChatScript-Engine-md#topic-and-rule-representation">Topic and rule representation</a></li>
<li><a href="ChatScript-Engine-md#natural-language-pipeline">Natural Language Pipeline</a></li>
<li><a href="ChatScript-Engine-md#messaging">Messaging</a></li>
<li><a href="ChatScript-Engine-md#error-handling">Error Handling</a></li>
<li><a href="ChatScript-Engine-md#multiple-bots">Multiple Bots</a></li>
<li><a href="ChatScript-Engine-md#private-code">Private Code</a></li>
<li><a href="ChatScript-Engine-md#documentation">Documentation</a></li>
</ul>
<p>This does not cover ChatScript the scripting language. It covers how the internals of the engine work and how to extend it with private code.</p>
<h1 id="code-zones">Code Zones</h1>
<div class="figure">
<img src="arch.png" alt="ChatScript architecture" />
<p class="caption">ChatScript architecture</p>
</div>
<p>The system is divided into the code zones shown below. All code is in SRC.</p>
<h2 id="core-engine">Core Engine</h2>
<ul>
<li><code>startup and overall control</code> is <code>mainSystem</code></li>
<li><code>dictionary</code> is <code>dictionarySystem</code></li>
<li><code>facts/JSON queries</code> is <code>factSystem</code>, <code>json</code>, <code>jsmn</code>, and <code>infer</code></li>
<li><code>topics</code> and loading the results of compilation is <code>topicSystem</code></li>
<li><code>functions</code> is <code>functionExecute</code></li>
<li><code>variables</code> is <code>variableSystem</code> and <code>systemVariables</code></li>
<li><code>memory allocation</code> and other things like file system access is in <code>os</code></li>
<li><code>output eval</code> is <code>outputSystem</code></li>
<li><code>system variable access</code> is <code>systemVariables</code></li>
<li><code>user variable access</code> is <code>variableSystem</code></li>
<li><code>pattern matching</code> is <code>patternSystem</code></li>
<li><code>text functions</code> is <code>textUtilities</code></li>
<li><code>if and loop</code> are in <code>constructCode</code></li>
</ul>
<h2 id="natural-language-stuff">Natural Language stuff</h2>
<ul>
<li><code>tokenization</code> is <code>spellcheck</code> and <code>tokenSystem</code></li>
<li><code>English pos-tagging and parsing</code> is <code>english</code> and <code>englishtagger</code> and <code>tagger</code></li>
<li><code>concept marking</code> is <code>markSystem</code></li>
</ul>
<h2 id="statefulness">Statefulness</h2>
<ul>
<li><code>long term user memory</code> is <code>userCache</code>, <code>userSystem</code></li>
</ul>
<h2 id="servers">Servers</h2>
<ul>
<li><code>server</code> abilities are in <code>csocket</code> (Windows) and <code>evserver</code>/<code>cs_ev</code> (Linux)</li>
</ul>
<h2 id="javascript">JavaScript</h2>
<ul>
<li><code>JavaScript</code> is in <code>javascript</code></li>
</ul>
<h2 id="databases">Databases</h2>
<ul>
<li><code>Mongo access</code> is <code>mongodb</code></li>
<li><code>Postgres access</code> is <code>postgres</code></li>
</ul>
<h2 id="ancillary">Ancillary</h2>
<ul>
<li>Test and Debug is in <code>testing</code></li>
<li>Script compiler is in <code>scriptCompile</code></li>
</ul>
<h2 id="folders-inside-src-are-external-systems-included-in-cs-including">Folders inside SRC are external systems included in CS, including:</h2>
<ul>
<li><code>curl</code> (web api handling/protocols for ^JSONOpen)</li>
<li><code>duktape</code> (JavaScript evaluation)</li>
<li><code>evserver</code> (LINUX fast server)</li>
<li><code>mongo</code> (Mongo db access)</li>
<li><code>mssql</code> (Microsoft SQL db access)</li>
<li><code>mysql</code> (MYSQL db access)</li>
<li><code>postgres</code> (postgres access)</li>
<li><code>unittest</code> (unit tests for mssql)</li>
<li><code>zlib</code> (text compression for databases - used for mssql at present)</li>
</ul>
<h1 id="character-set">Character set</h1>
<p>CS expects UTF8 both internally and in user data shipped to it. It may attempt to convert some user and script extended ascii or utf16 data to UTF8 on the fly, mostly related to funny quotes and doublequotes. Input which has characters will be converted to utf8, except for m-dash and n-dash. CS also transcodes some html constants</p>
<p>CS disallows use of the backtick in any user input or script so it can be dedicate to internal use. Such use includes: * <code>fact fields</code> - read and write fact fields that need escaping with back ticks instead of individual escapes, faster since don't have to interpret each character * <code>rules</code> - all compiled rules terminate with backtick to support fast scan to next rule * <code>transient variables</code> - values of transient variables have a hidden prefix of 2 backticks to support not allowing visibility of or changing of the value outside local ownership region * <code>dictionary words</code> - internal system words from dictionarysystem.h may have 1 or more backticks at start so no user word lookup could find them. the number of preceeding backticks indicates the kind of value the word has (property, sysstemflag, parsevalue, misc) * <code>user function definitions</code> - multiple bots redefining the same function have their definitions all concatenated together, separated with backticks and indictor of bot ownership * <code>keywords file</code> - multiple bots may use the same keywords in various concepts, each word is separated by a bot id using backtick</p>
<h1 id="user-data-representatino">User Data Representatino</h1>
<p>First you need to understand the basic data available to the user and CS and how it is represented and allocated.</p>
<div class="figure">
<img src="alloc.png" alt="ChatScript data allocations" />
<p class="caption">ChatScript data allocations</p>
</div>
<h2 id="text-strings">Text Strings</h2>
<p>The most fundamental datatype is the text string. This is a standard null-terminated C string represented in UTF8. Text strings represent words, phrases, things to say. They represent numbers (converted on the fly when needed to float and int64 values for computation). They represent the names of functions, concepts, topics, user variables, even CS script.</p>
<p>Strings are allocated out of either the stack (transiently for $_ transient variables) or the heap (for normal user variables and dictionary word names).</p>
<p>Strings can be part of facts (triples of strings) and the users input sentence is kept internally as an ordered array of strings.</p>
<h2 id="dictionary-entries">Dictionary Entries</h2>
<p>The second fundamental datatype is the dictionary entry (typedef WORDENTRY). A dictionary entry points to a string in the heap and has other data attached. For example, function names in the dictionary tell you how many arguments they require, where to go to execute their code. User variable names in the dictionary store a pointer to their value string (in the heap). Topic names track which bots are allowed to use them.</p>
<p>Dictionary entries have property bits (describing them re part of speech tagging), systemflag bits (more about usage of the word in English like does it require a direct object), internalBits (that may indicate features like is it a function definition, a query, a concept or topic, does it have uppercase letter in it anywhere, etc). See dictionarySystem.h for full form of typedef below:</p>
<pre><code>typedef struct WORDENTRY //   a dictionary entry
{
    char*     word;     
    union {
        char* userValue; 
    }w;
    MEANING  meanings;</code></pre>
<p>Ordinary words have multiple meanings which can vary in their part of speech and their ontology, so the list of possible meanings and descriptions is part of the dictionary entry. When working directly with a dictionary entry, the code uses <code>WORDP</code> as its datatype (pointer to a WORDENTRY). Code working indirectly with a dictionary entry uses <code>MEANING</code> as its datatype.</p>
<p>A <code>MEANING</code> is an index into dictionary space along with description bits that can say which meaning of the word is referred to (index into the meanings array of the dictionary entry) or which part of speech form (like noun vs verb) is being referred to. As a text string, a meaning can be either just the word (break) which represents all meanings. Or it can be a word with meaning index (break~33) which means the 33rd meaning of break. Or it can be a word with POS-tag (break~n) which means all noun meanings of &quot;break&quot;. These meanings can be used in concepts and keywords in patterns.</p>
<h2 id="facts">Facts</h2>
<p>The next fundamental datatype is the fact (typedef FACT), a triple of MEANINGs. The fields are called subject, verb, and object but that is just a naming convention and offers no restriction on their use.</p>
<p>A externally written fact looks like this:</p>
<pre><code>    ( Symantec_Norton_Security kindof software x500000 8192 )</code></pre>
<p>where the fact is contained within (). 3 main fields are shown, followed by a bit mask describing how to interpret the fields, and then a bot id identifying what bots are allowed to know this fact (this field is omitted if all bots can see it). Likewise if there the bit mask is 0, it too can be omitted.</p>
<p>Each field of a fact is either a <code>MEANING</code> (which in turn references a dictionary entry which points to a text string as name) or a direct index reference to another fact. As a direct reference, it is not text. It is literally an offset into fact space. But facts have description bits on them, and one such bit can say that a field is not a normal MEANING but is instead a binary number fact reference.</p>
<p>While fact references in a fact field are binary numbers, when stored in variables a fact reference is a text number string like 250066. It's still an index into fact space. When stored in external files (like user long-term memory or <code>^export</code>) facts are stored as full text as above. Externally facts are stored as pure text way because user facts get relocated every volley and cannot safely be referred to directly by a fact reference number.</p>
<h3 id="json-facts">JSON Facts</h3>
<p>CS directly supports JSON and you can manipulate JSON arrays and objects as you might expect. Internally, however, JSON is represented merely by facts with special bits that indicate how to interpret the the fact. JSON distinguishes primitive values (true, false, numbers, null) from strings, whereas CS uses strings for all of them and tracks how JSON writes them using bits on the fact. Here are 2 JSON facts:</p>
<pre><code>    ( jo-225 bluetoothdevice iPhone x2200 32 )
    ( ja-2 0 DUMPDATA x1200 32 ). </code></pre>
<p>The flags on these facts indicate that there are JSON facts (one a JSON object fact and one a JSON array fact). And that both have as their object value a JSON string. Unlike JSON which requires double quotes around all strings, CS requires no marker unless the string has internal blanks or double quotes. In which case, the text representation of the field is written with backticks like:</p>
<pre><code>    ( jo-225 bluetoothdevice `iPhone is good` x2200 32 )</code></pre>
<p>so that we don't have to store fancy escape markers on various internal characters. The backtick is the character solely reserved for CS to use in a variety of ways, and any user input containing such will have theirs automatically convered to a regular quote mark. It applies to any fact field, JSON or not. Internally there is no backtick in the text string. It literally has the spaces.</p>
<p>JSON objects and arrays are represented as synthesized dictionary entries with names like like <code>jo-5</code> or <code>ja-1025</code> for permanent JSON object or array and <code>ja-t7</code> for a transient array ('o' for object, 'a' for array, 't' for transient). The data for that array or object always has it's name as the first fact field. The numbers are generated uniquely on the fly when the JSON composite is created.</p>
<p>Each key-value pair of an object is a fact like <code>(jo-5 location Seattle x2200 )</code>. Each array element pair is a fact like <code>(ja-5 1 dog x1200)</code>. Array facts start with 0 as the verb and are always contiguously sequential (no missing numbers). Should you delete an element from the middle, all later elements automatically renumber to return to a contiguous sequence.</p>
<p>Variables holding JSON structures always just have the name of JSON composite, like <code>jo-5</code> or <code>ja-t2</code>. That name, when you retrieve its corresponding dictionary entry, will have the JSON facts bound to its subject cross-reference lists. Walking the structure will mean walking the lists of subject facts of that entry and subsequent JSON headers.</p>
<h1 id="data-storage">Data Storage</h1>
<p>The text data can be stored in various collections. One is merely the dictionary, where it is found again by using a copy (sometimes exact capitalization, sometimes any capitalization).</p>
<p>It can be stored individually in user variables.</p>
<p>A series of words in succession are stored in an internal sentence array and can be accessed indivually or by pattern matching. They disappear at the start of a new sentence.</p>
<p>A series of related words can be stored independently or sequentially in _n match variables. Match variable values last until overwritten, so it is possible to use them to communicate data across users and/or bots even (but it takes careful scripting).</p>
<p>A triple of related words can be stored in a fact. Facts can be transient (til end of volley) or saved in the user's data across volleys or the bot's data across users. They can be accessed by queries.</p>
<p>A collection of facts can be saved in a fact set (<span class="citation">@n</span>) which is an array that can be accessed sequentially from either end or randomly accessed. And the array can either use up what you access or remain unchanged.</p>
<p>Some small amount of text can also be saved on some system variables (%x) for transfer across users or volleys.</p>
<h2 id="user-variables">User Variables</h2>
<p>User variables are names beginning with $ that can be found in the dictionary and have data (not their name) pointing to text string values. Their prefix describes who can see their content and for how long.</p>
<pre><code>    $varname - globally visible  variable in heap lasting permanently across volleys
    $$varname - globally visible volley transient variable in heap which erases when volley ends
    $_varname - locally visible transient variable on stack only visible to the function or topic using them.</code></pre>
<h2 id="function-variables">Function Variables</h2>
<pre><code>    outputmacro: ^myfunc(^var1 $_var2) </code></pre>
<p>Normally variables to a function are local ones (like $_var2 above), visible only to that function. These are in computing terms &quot;call-by-value&quot;.</p>
<p>Function variables like ^var1 are &quot;call-by-reference&quot; variables and allow you to write back onto the caller with a new value. They are managed by the system outside of the dictionary. They are like $_varnames (local transient) but should be rare. Their value is the name of the thing being passed in, not its value.</p>
<h2 id="match-variables">Match Variables</h2>
<p>Match variables (<code>_0</code>) hold text strings directly. They use pre-reserved spaces and thus have limited sizes of strings they can hold (MAX_MATCHVAR_SIZE / 20000 bytes). They are expecting to hold parts of a sentence that have been matched and sentences are limited to 254 words (and words are typically small). Any larger data is truncated upon storage.</p>
<p>A match variable is more complex than a user variable because a match variable holds extra data from an input sentence. It holds the original text seen in the sentence, the canonical form of that value, and the position reference for where in the sentence the data came from.</p>
<p>Match variables pass all that information along when assigned to other match variables, but lose all but one of them when assigned to a user variable or stored as the field of a fact.</p>
<p>Some system functions take a string of a series of words and spread them onto a continuous region of match variables, using as many in a row to match the decomposition of the string. After all have been filled, the match varible after them is set to null.</p>
<h2 id="factset">Factset</h2>
<p>Querying for relevant facts results in facts stored in an array called a factset, labeled <span class="citation">@0</span>, <span class="citation">@1</span>, etc. You can also incrementally add values to the factset yourself. You treat these as arrays to retrieve a fact, normally specifying at the same time what part of the fact you want. But you can't directly specify the array index to retrieve from. You specify first, last, or next.</p>
<p>Typically you assign into a factset via a query like:</p>
<pre><code>    @2 = ^query(direct_sv my animal ?)</code></pre>
<h2 id="buffers">Buffers</h2>
<p>Input and output from CS involves potentially large text and so these have been preallocated from the heap as buffers. One allocates a buffer with AllocateBuffer() and one frees the most recent buffer with Freebuffer(). You don't have to pass a pointer to the buffer, you may only free them in the reverse order they were allocated. This follows the general memory management strategy of &quot;onion layers&quot;. Buffers are automatically freed at the close of levels of control invocation (eg calling a function) and during exception handling jumps.</p>
<h1 id="internal-lists">Internal lists</h1>
<p>The system needs to track lists of things, like global permanent variables whose values changed this volley (to write them out to user file). These lists are usually kept on the heap, though sometimes they reside on the stack. The list pushing routines are</p>
<pre><code>HEAPREF AllocateHeapval(HEAPREF linkval, uint64 val1, uint64 val2, uint64 val3 = 0);
STACKREF AllocateStackval(STACKREF linkval, uint64 val1, uint64 val2 = 0, uint64 val3 = 0);</code></pre>
<p>And the corresponding pop functions:</p>
<pre><code>HEAPREF UnpackHeapval(HEAPREF linkval, uint64 &amp; val1, uint64 &amp; val2, uint64&amp; val3 = discard);
STACKREF UnpackStackval(STACKREF linkval, uint64&amp; val1, uint64&amp; val2 = discard, uint64&amp; val3 = discard);</code></pre>
<h1 id="memory-management">Memory Management</h1>
<p>Many programs use malloc and free extensively upon demand. These are not particularly fast. And they lead to memory fragmentation, whereupon one might fail a malloc even though overall the space exists. ChatScript follows video game design principles and manages its own memory (except for 3rd party extensions like duktape and curl). It allocates everything in advance and then (with rare exception) it never dynamically allocates memory again, so it should not fail by calling the OS for memory. You have control over the allocations upon startup via command line parameters.</p>
<p>This does not mean CS has a perfect memory management system. Merely that it is extremely fast. It is based on mark/release (a kind of onion layer), so it allocates space rapidly, and at the end of the volley, it releases all the space it used back into its own pool. In the diagram below under Memory Allocation you have a list of all the areas of memory that are preallocated.</p>
<p>You might run out of memory allocated to dictionary items while still having memory available for facts. This means you need to rebalance your allocations. But most people never run into these problems unless they are on mobile versions of CS.</p>
<p>Stack and Heap memory are allocated out of a single chunk. Stack is at the low end of memory and grows upwards while Heap is at the high end and grows downward. If they meet, you are out of space.</p>
<p>Stack memory is tied to calls to <code>ChangeDepth</code> which typically represent function or topic invocation. Once that invocation is complete, all stack space allocated is cut back to its starting position. Stack space is typically allocated by <code>AllocateStack</code> and explicitly released via <code>ReleaseStack</code>.<br />
If you need an allocation but won't know how much is needed until after you have filled the space, you can use InfiniteStack and then when finished, use <code>CompleteBindStack</code> if you need to keep the allocation or <code>ReleaseInfiniteStack</code> if you don't. While <code>InfiniteStack</code> is in progress, you cannot safely make any more <code>AllocateStack</code> or <code>InfiniteStack</code> calls. There are 64-bit aligned versions of the stack allocation calls.</p>
<p>Heap memory allocated by <code>AllocateHeap</code> lasts for the duration of the volley and is not explicitly deallocated. It will be implicitly deallocated at the end of the volley. But during the volley one could imagine that some heap memory is no longer in use but hasn't been freed until the end of the volley. (This is something that automatic garbage collectors handle but CS has only a manual garbage collection). The heap allocation calls are told the size of a unit and how many, so they automatically handle needed alignment.</p>
<p>Fact memory is consumed by <code>CreateFact</code> or various JSON assignment statements and lasts for the duration of the volley. Facts can be deleted, so they are no longer visible, but their memory is not reclaimed until end of volley.</p>
<p>Buffers are allocated and deallocated via <code>AllocateBuffer</code> and <code>FreeBuffer</code>. Typically they are used within a small block of short-lasting code, when you don't want to waste heap space and cannot make use of stack space. While there are a small amount of them preallocated, in an emergency if the system runs out of them it can malloc a few more.</p>
<p>TCP buffers are dynamically allocated (violating the principle of not using malloc/free) via accept threads of a server.</p>
<p>Output buffers refer to either the main user output buffer or the log buffer. The output buffer needs to be particularly big to hold potentially large amounts of OOB (out-of-band) data being shipped externally.</p>
<p>Also most temporary computations from functions and rules are dumped into the output buffer temporarily, so the buffer holds both output in progress as well as temporary computation. So if your output were to actually be close to the real size of the buffer, you would probably need to make the buffer bigger to allow room for transient computation.</p>
<p>Cache space is where the system reads and writes the user's long term memory. There is at least 1, to hold the current user, but you can optimize read/write calls by caching multiple users at a time, subject to the risk that the server crashes and recent transactions are lost. A cache entry needs to be large enough to hold all the data on a user you may want saved.</p>
<h1 id="onion-layers">Onion Layers</h1>
<p>When ChatScript starts up, it loads data in layers. You can free a layer at a time, but only the outermost one (hence the peeling the onion metaphor).</p>
<p>First layer is all the permanent data associated with the system, which is printed out as <code>WordNet:</code> and loads dictionary entries and facts. It generates some concepts and loads LIVEDATA information.</p>
<p>Then the system loads data from the TOPIC folder. <code>Build0:</code> layer and then <code>Build1:</code> layer. These contain facts, more dictionary data, concept sets, variables with values, and scripted function definitions.</p>
<p>Then if there is a boot function, it executes and additional data can be brought into the boot layer.</p>
<p>The system is now ready for user inputs. User folder data has a topic file to represent a user talking to a specific bot. That data is read into the user layer. The input volley alters content of the layer and outputs messages to the user. Changes in facts and user variables as well as execution state of topics are stored back into the user's topic file. Then the user layer is peeled off and the system is ready for another user.</p>
<p>All layers are &quot;peelable&quot;. And all layers are protected from harm by later layers. However, it is possible to create facts (and hence dictionary entries) in the user layer and migrate some of them into the boot layer when the user volley is finished. This means that data will be globally visible in the future to all users.</p>
<p>When you create a new fact, the corresponding dictionary entry for each field either already exists or is newly created. The entry has lists for each field it participates in and the fact is added to the head of that list. This coupling needs to be unwound when we want to remove a layer.</p>
<p>When we want to peel a layer, we walk facts from most recently created to start of the layer. By going to the dictionary entry of a field, that fact will be the current first entry of the list, so we merely pop it from the list and that decouples fact and dictionary entry. Once decoupled, all newly created dictionary entries are no longer needed so the free entry pointer can be reset to the start of the layer. And all user layer facts have been written out to a file, so we can reset the free fact pointer as well.</p>
<p>Similarly all factsets that need saving were written out, so they can all be reset empty. User variables will also have been written out, so they too can have their values cleared so they are no longer pointing into the heap. Nothing from the volley will now be occupying any heap memory and so its pointer can be reset back to start of layer.</p>
<h2 id="garbage-collection">Garbage collection</h2>
<p>Using the layer model, normally user conversation causes heap allocations and dictionary allocations that can be rapidly and automatically released when the user layer is peeled. And plenty of space should exist to manage without any garbage collection occurring within the volley.</p>
<p>The problem of free memory mostly shows up in document mode. You can read an entire book in document mode, which means a lot of sentences. This is all considered a single volley and therefore one might run out of memory.</p>
<p>CS provides <code>^memorymark</code> and <code>^memoryfree</code> so you can explicitly control this while reading a document. You find a safe place in script to use mark, you process a sentence, and then you use release to restored dictionary and heap values back to the mark. Using ^memoryfree returns you to exactly where you were memory-wise at the time you marked (reverting variables and releasing facts as needed).</p>
<p>Nominally this means all facts and user variables you worked on after the mark will be lost. This is fine if your results are going to an external place (like writing to a file with ^log). Failing that, there are a couple of mechanisms for passing data back across a ^MemoryFree. You can write something onto a match variable. Match variables have their own memory and last until changed. Or when you call ^MemoryFree, you may pass either a single variable or a JSON structure on the call. Its value will be protected. The value is copied into stack space, the release occurs, and then the value is reallocated from the current full heap (now without the mark location). .</p>
<p>And more recently provides <code>^memorygc</code> which copies data from heap to stack, and then copies back only the currently used data.</p>
<p>The complex gc is an actual gc, where data is moved around and space gets recompacted after discarding trash. Normally facts consist of MEANINGS, and those dictionary entries know what facts refer to them. So things can be shuffled around. EXCEPT...</p>
<p>Facts don't know what factsets they may be listed in, and facts that later facts directly refer to by index are unaware of it. And JSONLOOP is maintaining facts it is using and will be unaware if they are relocated. And if you request a fact id from some query result, that id is really only good for the duration of the volley, and not safe across a gc because it will be stored on a variable which has no cross-reference from the fact. So care is required to use the complex gc mechanism.</p>
<h2 id="finer-details-about-words">Finer details about words</h2>
<p>Words are the fundamental unit of information in CS. The original words came from WordNet, and then were either reduced or expanded. Word are reduced when some or all meanings of them are removed because they are too difficult to manage. <code>I</code>, for example, has a Wordnet meaning of the chemical iodine, and because that is so rare in usage and causes major headaches for ChatScript (noun instead of pronoun), that definition has been expunged along with some 500 other meanings of words.</p>
<p>Additional words have been added, including things that Wordnet doesn't cover like pronouns, prepositions, determiners, and conjunctions. And more recent words like <code>animatronic</code> and <code>beatbox</code>. Every word in a pattern has a value in the dictionary. Even things that are not words, including phrases, can reside in the dictionary and have properties, even if the property is merely that this is a keyword of some pattern or concept somewhere.</p>
<p>Words have zillions of bits representing language properties of the word (well, maybe not zillions, but 3x64 bytes worth of bits). Many are permanent core properties like it can be a noun, a singular noun, it refers to a unit of time (like <code>month</code>), it refers to an animate being, or it's a word learned typically in first grade. Eg.,</p>
<pre><code>typedef struct WORDENTRY //   a dictionary entry
{
    uint64  properties;      
    uint64  systemFlags;    
    unsigned int internalBits;
    unsigned int parseBits;         </code></pre>
<p>Other properties result from compiling your script (this word is found in a pattern somewhere in your script). All of these properties could have been represented as facts, but it would have been inefficient in either cpu time or memory to have done so.</p>
<p>Some dictionary items are <code>permanent</code>, meaning they are loaded when the system starts up, either from the dictionary or from data in layer 0 and layer 1 and layer 2 (boot layer). Other dictionary items are <code>transient</code>. They come into existence as a result of user input or script execution and will disappear when that volley is complete. They may live on in text as data stored in the user's topic file and will reappear again during the next volley when the user data is reloaded. Words like dogs are not in the permanent dictionary but will get created as transient entries if they show up in the user's input.</p>
<p>The dictionary consists of <code>WORDENTRY</code>s, stored in hash buckets when the system starts up. The hash code is the same for lower and upper case words, but upper case adds 1 to the bucket it stores in. This makes it easy to perform lookups where we are uncertain of the proper casing (which is common because casing in user input is unreliable). The system can store multiple ways of upper-casing a word.</p>
<p>The ontology structure of CS is represented as facts (which allows them to be queried). Words are hierarchically linked (WordNet's ontology) using facts (using the <code>is</code> verb). Words are conceptually linked (defined in a <code>~concept</code> or as keywords of a <code>topic</code>) using facts with the verb <code>member</code>.</p>
<p>Word entries have lists of facts that use them as either subject or verb or object. So do facts.</p>
<pre><code>typedef struct WORDENTRY //   a dictionary entry
{
    FACTOID subjectHead;
    FACTOID verbHead;
    FACTOID objectHead;

typedef struct FACT 
{  
    FACTOID_OR_MEANING subjectHead; 
    FACTOID_OR_MEANING verbHead;        
    FACTOID_OR_MEANING objectHead;      
    FACTOID_OR_MEANING subjectNext; 
    FACTOID_OR_MEANING verbNext;        
    FACTOID_OR_MEANING objectNext;      </code></pre>
<p>So when you do a query like</p>
<pre><code>^query(direct_sv dog love ?)</code></pre>
<p>CS will retrieve the list of facts that have <code>dog</code> as a subject and consider those whose verb is <code>love</code>. And all those values of fields of a fact are words in the dictionary so that they will be able to be queried.</p>
<p>Queries like</p>
<pre><code>^query(direct_v ? walk ?)</code></pre>
<p>work by having a byte code scripting language stored on the query name <code>direct_v</code>. This byte code is defined in <code>LIVEDATA</code> (so you can define new queries) and is executed to perform the query. Effectively facts create graphs and queries are a language for walking the edges of the graph.</p>
<p>ChatScript supports user variables, for considerations of efficiency and ease of reference by scripters. Variables could have been represented as facts, but it would have increased processing time, local memory usage, and user file sizes, not to mention made scripts harder to read.</p>
<h1 id="function-run-time-model">Function Run-time Model</h1>
<p>The fundamental units of computation in ChatScript are functions (system functions and user outputmacros) and rules of topics. Rules and outputmacros can be considered somewhat interchangeable as both can have code and be invoked (rules by calling <code>^reuse</code>). And both can use pattern matching on the input.</p>
<p>Function names are stored in the dictionary and either point to script to execute or engine code to call, as well as the number of arguments and names of arguments.</p>
<p>System functions are predefined C code to perform some activity most of which take arguments that are evaluated in advance (but use <code>STREAMARG</code> and the function waits until it gets them to decide whether to evaluate or not). System functions can either designate exactly how many arguments they expect, or use <code>VARIABLE_ARGUMENT_COUNT</code> to allow unfixed amounts.</p>
<p>Outputmacros are scripter-written stuff that CS dynamically processes at execution time to treat as a mixture of script statements and user output words. They can have arguments passed to them as either call by value ($_var) or call by reference (^var). The scripter functions are loaded from <code>macros0.txt</code> and <code>macros1.txt</code> In the TOPIC folder. Functions are stored 1 per line, as compilation goes along. Functions are potentially &quot;owned&quot; by a bot, so more than one line may define the same function.</p>
<pre><code>^car_reference o 2048 0 A( ) ...compiled script... </code></pre>
<p>The name (^car_reference) is followed by the kind of function (outputmacro, tablemacro, patternmacro, dualmacro), followed by the bot bits allowed to use this function (2048 bot), followed by flags on the function (0), followed by the number of arguments. It expects (0). Argument count is 'A' + count when count &lt;= 15 and 'a' + count - 15 when greater. If the letter is uppercase, it means function supports variable argument count.</p>
<p>The value of the dictionary entry of the function name is a pointer to the function data allocated in the heap. Multiple definitions of the name are chained together, and the system will hunt that list for the first entry whose bot bits allow use.</p>
<p>Patternmacros are scripter-written patterns that allow some existing pattern to transfer over to them and back again when used up. They have the same format as outputmacros, but their code data is simply the pattern to execute. The pattern code merely switches over to this extension code until it runs out, and resumes its normal code. You can't nest patternmacro calls at present.</p>
<p>All system functions return both a text buffer answer and an error code. For error codes see the section on error handling.</p>
<h2 id="when-functions-can-be-run">When functions can be run</h2>
<p>There are three time frames that functions can be invoked: compile-time, startup-time (boot time), and user script execution. Compile-time function calls can be made from table: declarations, providing the function has already been defined. If you define a function called ^CSBOOT(), that gets executed as the system starts up and it can then invoke anything else. And otherwise scripts executed per user volley can invoke any function.</p>
<h2 id="argument-passing">Argument Passing</h2>
<p>There are actually two styles of passing arguments. Arguments are stored in a global argument array, referenced by ARGUMENT(n) when viewed from system routines. The call sets the current global index and then stores arguments relative to that. Outputmacros use that same mechanism for call-by-reference arguments. Call by reference arguments start with <code>^</code> like <code>^myarg</code> and the script compiler compiles the names into number references starting with <code>^0</code> and increasing <code>^1</code> ... <code>^myarg</code> style allows a routine to assign indirectly to the callers variable.</p>
<p>But outputmacros also support call by value arguments which start with <code>$_</code> like <code>$_myarg</code>. No one outside the routine is allowed to change these or use these to access the above caller's data. Hence call by value. These are normal albeit transient variables so the corresponding value from the argument stack is also stored as the value of the local variable. That happens after the function call code first saves away the old values of all locals of a routine (or topic) and then initializes all locals to NULL. Once the call is finished, the saved values are restored.</p>
<p>When passing data as call by value, the value stored always has a backtick-backtick prefix in front of it. In fact, all assignments onto local variables have that prefix prepended (hidden). This allows the system to detect that the value comes from a local variable or an active string and has already been evaluated. Normally, if the output processor sees <code>$xxx</code> in the output stream, it would attempt to evaluate it. But if it looks and sees there is a hidden back-tick back-tick before it, it knows that <code>$xxx</code> is the final value and is not to be evaluated further.</p>
<p>Back-tick (`) is a strongly reserved character of the engine and is prevented from occurring in normal data from a user.</p>
<pre><code>* marks variable data coming preevaluated. 
* marks ends of rules in scripts. 
* quote values of variables and fact fields when writing out to the user&#39;s topic file.
* creates specific internal dictionary entries that cannot collide with normal words.</code></pre>
<h1 id="script-execution">Script Execution</h1>
<p>Execution, be it pattern matching or output processing, proceeds token by token. There is not really much of building up tokens on a stack and then popping them as needed (like calculator functionality). This means you cannot write parenthesized numeric expressions nor use function calls as arguments to other function calls.</p>
<h2 id="evaluation">Evaluation</h2>
<p>Script execution involves one-by-one evalutation of tokens. It happens in patterns and if tests. It happens in the output side of a rule. It happens in function execution and it happens in interpreting the arguments to a function. It happens in active strings.</p>
<p>Numbers and words just evaluate to themselves. As do factset references like <span class="citation">@4</span> and concept set names like ~animals.</p>
<p>User variables ($, $$, $_) evaluate to their value, unless they are dotted or subscripted, in which case they evaluate to their content and then perform a JSON object lookup. Or if the token immediately after it is an assignment operator of some kind (e.g. = += -= etc).</p>
<p>System variables (%) evaluate to their value. Not generally advised but for some system variables it may make sense to use them of the left hand of assignment statements.</p>
<p>Match variables (<code>_0</code>) evaluate to their content, original or canonical depending on whether the reference is quoted or not.</p>
<p>Function calls evaluate to their returned result and absorb tokens from ( to ) . Be advised you cannot usually use a function call as an argument to another function. You'll need to assign the first call to a variable, and then use the variable as argument to the second function.</p>
<p>Active strings ^&quot;xxx&quot; and ^'xxx' process their content in the moment of use.</p>
<h2 id="spacing">Spacing</h2>
<p>The script compiler normally forces separate things into separate tokens to allow fast uniform handling. E.g., <code>^call(bob hello)</code> becomes <code>^call ( bob hello )</code>. This allows the <code>ReadCompiledWord</code> function to grab tokens more easily.</p>
<h2 id="prefix-characters">Prefix characters</h2>
<p>The engine is heavily dependent upon the prefix character of a script token to tell the system how to process script. The pattern prefixes are:</p>
<pre><code>=   to designate a comparison operator
!   to invert a Test
?   a unary existence operator (prefixing a variable)
@_1+ to indicate jumping in a pattern to a location and altering direction (+ or -)</code></pre>
<p>Prefixes also used in patterns and output code are:</p>
<pre><code>$   to indicate user variables
%   to indicate system variables
_1  to indicate a specific match variable
^   to indicate function calls, function in-out variables
~   to indicate a concept set (but this has no impact on execution of tokens)
@1  to indiate a specific numbered factset 
&#39;   to indicate to use the original value of a match variable or word 
#   to indicate a system defined numeric constant (or to indicate comment to end of line)
^^  to indicate indirection assignment thru an in-out function variable</code></pre>
<h2 id="skip-codes">Skip codes</h2>
<p>The script compiler puts in characters indicating how far something extends to allow faster execution. This jump value is used for things like if statements to skip over failing segments of the if. It is used for knowing where a pattern label ends and even for skipping over entire rules.</p>
<p>Skip codes (1 or 3 characters that represent a number) allow the system to move rapidly in the code stream.</p>
<h3 id="rule-and-label-skips">Rule and Label skips</h3>
<p>Every rule starts with a skip code that tells the offset needed to skip past this rule and move to the next rule. The system view of a rule is normally starting with the kind (u:) but it can back up 4 characters to read the skip code if it needs it. There is also a 1 character skip code in front of any rule label, that tells the width of the label to get to the opening paren of the rule's pattern.</p>
<pre><code>00J u: &lt;RULE_LABEL ( test ) This is a rule. </code></pre>
<h3 id="comparison-skip">Comparison skip</h3>
<p>Comparison conditions in patterns use a 1 character skip at the start of a comparison token to index to the start of the operator (i.e., to know where the end of the variable name is). The leading <code>=</code> is the prefix code that says this token is a comparison token.</p>
<pre><code>u: ( =6$foo==5 )</code></pre>
<h3 id="if-and-loop-skips">IF and LOOP skips</h3>
<p><code>if</code> and <code>loop</code> are actually functions. And they use 3 character skip codes to move around the pieces.</p>
<pre><code>u:  (test) if ($val) {do this} else if ($val1) {do that} else {anyway} .
u: ( test ) ^if 00c( $val ) 00j{ do this } 00? else 00d( $val1 ) 00j{ do that } 00y else ( 1 ) 00i { anyway } 004 .</code></pre>
<p>The second line shows the compiled form of a complex <code>if</code>. <code>if</code> is compiled into the ^prefixed form (since it is not something to echo as a word to the user). The 00c skip code before the first test is the offset to get the other end of the first test, where another skip code lies. Whether the test succeeds or fails, this will get us past the test immediately. The next skip code (00j) can take us past the code to for this branch of the if. If the test fails, you would use that skip to bypass the &quot;do this&quot; and point to the next <code>else</code>. The skip code after the end of the &quot;do this&quot; process tells how to skip to the end of the entire if, so normal execution can resume.</p>
<p>Loops uses a skip code, to allow it to jump to the end of the loop when the loop condition fails.</p>
<pre><code>u:  (test)  loop(1) { do this }
u: ( test ) ^loop ( 1 ) 00g { do this } </code></pre>
<h1 id="rule-tags">Rule Tags</h1>
<p>CS executes rules. While scripters can add their own label to a rule, all rules are automatically labelled internally by their position in a topic. The topic has a list of rules, numbered from 0 ... for top level rules. Top level rules can have rejoinders, which are numbered from 1 ... The system creates a text rule tag like: ~books.12.0 which means in the topic books, the 13th top level rule, and at the top level (not a rejoinder). ~books.12.3 is the third rejoinder under top-level rule 12. Internally a rule id has the bottom 16 bits for top level id and the next 16 for the rejoinder id.</p>
<p>Engine function arguments involving rules can accept either user labels or rule tags. While rule tags are completely unique, nothing prevents a user from labelling multiple rules in a topic with the same label, which is sometimes useful (eg in ^reuse for finding a rule not yet disabled or in ^incontext).</p>
<h1 id="concept-representation">Concept representation</h1>
<p>A concept is a word beginning with ~. Ideally it has a bit on it that tells us that it is an officially compiled concept or topic (topics are also concepts via their keywords list). Members of the concept are facts whose verb is <code>member</code> and whose object is the concept name. Since these facts are stored as references from the concept name in object field position, all members can be found (including ones merely defined by <code>^createfact(myname member ~someconcept))</code>. One can even generate a fake sort of concept set, by doing <code>^createfact(dog member pet))</code>. This causes references to <code>dog</code> to automatically mark <code>pet</code> and propogate along any concepts of including that.</p>
<p>In the TOPIC folder are the files <code>keywords0.txt</code> and <code>keywords1.txt</code>. Since concepts are represented as facts, the data needed is the name of the concept/topic, the list of keywords to create into facts upon loading is provided, along with the bot bits that identify which bots can see that fact. Below's first entry is a topic (T~) and the second is a concept. The third is a concept with concept flags and because it comes from a multi-bot environment so each word is joined to the botbits that can see that keyword.</p>
<pre><code>T~introductions ( here name ~emohowzit ~emohello ~emogoodbye )
~introductions ( here &#39;name ~emohowzit ~emohello ~emogoodbye )
~black PROBABLE_ADJECTIVE ( dead`16 dark`16 blank`16 )</code></pre>
<p>An apostrophe in front of the word means only that word and not any conjugations of it.</p>
<p>Concepts also allow patterns as members, but they are not saved as member facts. They are saved as conceptpattern facts, where the subject is the pattern and the object is the concept name. They are executed after the normal NL pipeline is complete. The pattern can be compiled or uncompiled. Coming from compiling script they are compiled. Coming from a function like ^testpattern they may or may not be compiled. If uncompiled, the system will compile them first, every volley. A concept pattern looks like below- i.e. a double-quoted pattern as you would find it in any rule.</p>
<pre><code>concept: ~romance( &quot;(boy finds girl)&quot; &quot;( [boy girl] meet [boy girl]) &quot; romance )</code></pre>
<p>Concepts can contain other concepts as members. When you build a concept by including another concept, you can also elect to exclude specific subconcepts or words. In the representation for this, all normal concept facts are last in the list and exclusions are first. So a word that wants to trigger a concept must first pass against the exclusions list. Set exclusions are in the middle, while the start of the members are the single words that must be excluded. Therefore in the marking phase, when we have a word and we are chasing up what concepts its a member of, if the word is in the simple excludes list, we dont continue marking That set with it. If the exclusions are sets, we have to defer decision making until other paths have been chased up, to see if the set has been marked.</p>
<h1 id="pattern-matching">Pattern matching</h1>
<p>Patterns can exist at the start of any rule type. And they can exist inside of <code>IF (PATTERN ...)</code> statements.</p>
<h2 id="token-processing">Token processing</h2>
<p>Pattern matching executes the pattern stream token by token. A token might be a word, or a wildcard, or an entire assignment statment with active string like `$tmp:=^&quot;This ^compute(a sub b)&quot;. The script compiler will force spaces between tokens, particular ones with special priority like &lt; or [ or (.</p>
<pre><code>u: (&lt;[a b c])  -- sample script
u: ( &lt; [ a b c ] ) -- compiled notation</code></pre>
<p>The exception to the token by token rule is function calls, where when the function name token is detected, it gets control over the pattern stream to manage the <code>(</code> and arguments and <code>)</code> .</p>
<h2 id="legal-gaps">Legal gaps</h2>
<p>A top-level pattern <code>( a )</code> implicitly means <code>( &lt; * a )</code> except that since we dont actually use the <code>&lt;</code>, backtracking will work. When a substantive (non-wildcard) match happens, the system moves the current marker of where we are in the sentence to that position. However, the movement from the prior position to this new one must be legal. When wildcards are involved as the predecessor token, they define how much gap is allowed. when non-wildcard tokens are involved, there is no gap and the new match must immediately follow OR be coincident within the current position.</p>
<h2 id="backtracking">Backtracking</h2>
<p>Unlike regex or prolog, CS pattern matching does not do full backtracking on failure (as that would be expensive). Instead if the system tracks the first real word it matches, and if the pattern fails, it can retry the entire pattern starting after that first match. Anything that forces a location in the pattern will inhibit this, e.g.,</p>
<pre><code>u: (&lt; test)
u: (@_0+ try)</code></pre>
<p>The above patterns, when reexecuted, would force the start of matching again, so backtracking is not feasible.</p>
<p>Because backtracking is limited, one should prefer using concept sets to using <code>[ xxx yyy zzz]</code> because concept sets find the closest match to your current position whereas the [ ] try to match in order, and thus may find matches much later in the sentence. Additionally one should strive to try to find the most significant words first, ones less likely to be found in the sentence. E.g.,</p>
<pre><code>u: ( I want * the adjustment )  -- can find the anywhere and never backtrack to adjustment
u: ( I want * _adjustment @_0- the)  -- finds the rare word adjustment and then confirms the</code></pre>
<h2 id="pattern-macros">Pattern macros</h2>
<p>Pattern macros are merely patterns encased by a function call. In execution, when a pattern macro is encounterd, the system temporarily changes its pattern stream pointer to use the definition of the macro and then on failure or match, restores the old stream to continue. This only works for 1 call; you cannot nest a call to a pattern macro from within a pattern macro.</p>
<h1 id="supplemental-dictionary-data">Supplemental dictionary data</h1>
<p>The TOPIC files <code>canon0.txt</code> and <code>canon1.txt</code> hold results of compiling the <code>canon:</code> declaration. Each line is a pair of words, the original and what it's canonical should be. Similarly <code>private0.txt</code> and <code>private1.txt</code> files hold pairs spell-check replacements, though they can handle multiple word in and multiple word out.</p>
<p>The files <code>dict0.txt</code> and <code>dict1.txt</code> handle words whose property bits have been created or changed by compilation. You can explicitly add words to the dictionary using <code>word: futzle NOUN</code> where the first argument is the canonical form of the word. If the word is a noun and you have an irregular plural, you can put futzle / futzlet to indicate the plural form. If the word is a verb you can use <code>word: futzle VERB</code> and if it has irregular conjugation you can add the past and past particple using <code>word: futzle / futzled / futzled VERB</code>. Other system flags and parseflags can be added like word: futzle / futzled / futzled VERB VERB_NOOBJECT VERB_DIRECTOBJECT` which indicates this verb can accept either a direct object or none.</p>
<h1 id="topic-and-rule-representation">Topic and rule representation</h1>
<p>Topic keywords are stored along with concept keywords in the keywordsn.txt files. The files <code>topic0.txt</code> and <code>topic1.txt</code> contain the rest of topic data. Each entry consists of 2 lines. The first tells you its a topic, names it, and names various flags and properties about it including where it is defined in source. The second line first lists all botnames allowed to use this topic and then begins listing all the rules.</p>
<pre><code>TOPIC: ~chatbots 0x1b 53459696 34 0 2798 chatbots.top
&quot;  mybot  &quot; 012 ?: ( do * you * ~like * robot ) Robots are cool. `</code></pre>
<p>Rules start with a jump index to the next rule(012), have their rule type(?:), pattern, and output. A rule ends with the backtick mark.</p>
<p>If there are multiple copies of the topic (due to multiple bots), they are just another line pair show botname list will be different.</p>
<h1 id="error-handling">Error handling</h1>
<p>There are two kinds of error handling, rule-based and engine based.</p>
<p>All script-callable engine Functions are declared <code>FunctionResult</code> and return NOPROBLEM_BIT when things are fine. Other codes indicate whether to terminate a rule, topic, sentence, or input as OK or an error. In script you can suppress errors from below by kind, e.g., <code>^nofail(TOPIC ...)</code>. Or you can trap all errors and examine what termination happened via <code>^result( ... )</code>.</p>
<p>The engine tries to detect and recover from various error conditions. It uses <code>ReportBug</code> to add an entry into LOGS/bugs.txt (and the server log if a server). Any error message starting with <code>FATAL</code> means that the call will not return; CS will end execution instead. Fatal errors are not trapped by a try/catch or setjmp/longjump mechanism because it is too risky. Bits in the dictionary may have been changed or some kind of memory overwrite may have happened. This would leave the server damaged for all future volleys. Instead, the server exists. External processes restart the server (and may retry the volley) and the fully reloaded server will be clean and ready to continue.</p>
<p>The API functions (^compilepattern, ^compileoutput, ^testpattern, ^testoutput) have special error handling for BADSCRIPT calls, which will return the error message to the caller in an errors field, rather than report to a bug/server/user log.</p>
<h1 id="messaging">Messaging</h1>
<p>CS user messaging design involves several features: directness, cancelability, and accountability.</p>
<p>Directness:</p>
<p>Normal computer languages have computation as the main goal, with user output as a last result. But a chatbot language has user output as the main goal and may or may not ever involve computation. Since ChatScript strives to make it easy to create chatbots, it heads in a different direction from Normal languages. A normal language might output to the user like this:</p>
<pre><code>    printf(&quot;The result is %d for %s units.&quot;, value, units);</code></pre>
<p>But this involves typing extraneous function calls and punctuation and creating dummy values and putting real values later, where errors in order or count might occur. In CS this would be:</p>
<pre><code>    The result is $value for $units.</code></pre>
<p>Cancelability:</p>
<p>CS is evaluating tokens for output to the user as it goes along. This may mean processing words, or variables, or functions. But a function might fail, and we don't want to send a partial output to the user. So what we do is<br />
put tokens into a transient output stream. If at any time we &quot;fail&quot;, then we simply discard the stream. If, however, we succeed, then the stream is transferred into a message unit to be shipped to the user later when we are done.</p>
<p>Accountability:</p>
<p>Each message unit saves the message (typically one or more sentences) and the rule that generated it. In order to have this accountability, no message unit can cross multiple rules (though a rule may choose to generate multiple message units). Because we have the name of the rule involved, we can later know why the message arose (with good rule naming) and even decide to revise or delete the message entirely.</p>
<p>To achieve this, whenver a rule completes, it transfers any output from the transient output stream into being a message unit. Furthermore, if a rule would transfer control to another rule, it transfers what it has so far into a message unit. It may generate more transient output after it returns from whatever rule it invoked. Rule transfers happen with: ^gambit, ^respond, ^refine, ^sequence, ^reuse. ^retry, while not triggering a new rule, re-triggers this rule and causes this behavior, as does ^print which is an explicit request to generate a message unit. Also ^postprintbefore and ^postprintafter. And ^flushoutput.</p>
<p>While there may be many message units to show to the user, the result is merely to concatenate them with space separators. So from the user's view there is no visibility over &quot;message units&quot;, there is just the resulting message.</p>
<h1 id="natural-language-pipeline">Natural Language Pipeline</h1>
<p>CS pre-processes user input to make it easy to find meaning within it. These are both classic and unusual NL processing steps. All steps in the pipeline use data representations that work together. Much of the work aims toward normalization, that is making different ways of typing in the same thing look the same to scripts, so they don't have to account for variations (making script writing and maintenance easier). Other than tokenization, all other pipeline steps are under control of the script (<code>$cs_token</code>), which can choose to use any combination of them at any time.</p>
<div class="figure">
<img src="NLPipeline.png" alt="ChatScript NLP pipeline" />
<p class="caption">ChatScript NLP pipeline</p>
</div>
<h2 id="tokenization">Tokenization</h2>
<p>Tokenization is the process of taking a stream of input characters and breaking it into sentences consisting of words and punctuation (tokens).</p>
<p>ChatScript can process any number of sentences as a single input, but it will do so one at a time. In addition to the naive tokenization done by other systems, CS also performs some normalizations at this point.</p>
<p>This is also where out-of-band (OOB) data gets split off from user input. ChatScript can send and receive information from the user and the application simultaneously.</p>
<p>Inbound OOB can pass along any context like what category and specialty the user is starting in or what sensors have seen of the user (gesture recognition, etc).</p>
<p>Outbound OOB can tell the system how to manipulate an avatar, why the current outgoing user message was emitted, or any other special system data. The CS convention for OOB is that it is always first in the message and is encased in <code>[</code> <code>]</code>.</p>
<p>The input is a stream of characters. If there is OOB data, this is detected and split off as a single sentence in its own right. The rest of the input is then separated into the next sentence and the leftover unprocessed characters. A sentence has a 254 word limit, so anything attempting to be one beyond that will be split at that boundary.</p>
<p>Tokenization tries to separate into normal words and special tokens, e.g. <code>I like (this)</code>. tokenizes into <code>I like ( this )</code> . It has a bunch of decisions to make around things like periods and commas. Is the period a sentence end or an abbreviation or web url or what? Is a comma a part of a number or a piece of punctuation of the sentence? If something is a <code>12/2/1933</code> date, it can be separated into <code>12 / 2 / 1933</code> which leaves the decision to date merge or not under control of the scripter.</p>
<p>The process of tokenization is not visible to the script. It cannot easily know what transformations were made. This becomes the real sentence the user input, and is visible from the ^original function. You can see the result using <code>:tokenize  some sentence</code>.</p>
<h2 id="substitution">Substitution</h2>
<p>Substitution involves replacing specific tokens or token sequences with different ones. Substitutions come from the LIVEDATA folder or <code>replace:</code> in scripts. A substitution represents sequences of words one might expect and how you might want to revise them. Revisions are either to correct the user input or make it easier to understand the meaning by converting to a standard form. The files include:</p>
<ul>
<li>british: a british spelling and its american equivalent like <em>colour</em> into <em>color</em></li>
<li>contractions: expands contractions like <em>don't</em> into <em>do not</em></li>
<li>interjections: revises dialog acts like so long. into <code>~emogoodbye</code> or <em>sure.</em> into <code>~yes</code></li>
<li>noise: removes useless words like <em>very</em> or <em>I mean that</em></li>
<li>spellfix: common spelling mistakes that might be hard for spellcheck to fix correctly</li>
<li>substitutes: for whatever reason - e.g. Britain into Great Britain</li>
<li>texting: revise shorthands into normal words or interjections like <em>:)</em> into <code>~emohappy</code></li>
</ul>
<p>The format is typically original word followed by replacement. E.g.</p>
<pre><code>    switc  switch</code></pre>
<p>To represent multiple words to handle on input, separate them with underscores or place in double quotes. To indicate the word must be a sentence start use &lt; and a sentence end use &gt;. To represent multiple words on output, use + between the words. An underscore in output means issue the data as you see it, a composite word with underscore between. This is how Wordnet represents multiple word entries.</p>
<pre><code>    &lt;real_estate&gt; my+holdings</code></pre>
<p>The above detects the two word sentence <code>real estate</code> and converts it into two different words <code>my holdings</code></p>
<h2 id="spell-check">Spell check</h2>
<p>Standard spell check algorithms based on edit distance and cost are used, but only among words which are of the same length plus or minus one.</p>
<p>The system also checks for bursting tokens into multiple words or merging multiple tokens into a word, and makes decisions about hypenated words.</p>
<p>For English, since the dictionary only contains lemma (canonical) forms of words, it checks standard conjugations to see if it recognizes a word.</p>
<p>For foreign languages, the engine lacks the ability to conjugate words, so the dictionary needs to include all conjugated forms of a word.</p>
<h3 id="merging">Merging</h3>
<p>Merging converts multiple tokens into single ones that can be manipulated more easily. One can have proper names merged (<em>John Smith</em>  <em>John_Smith</em>) which supports the classic named-entity extraction (finding proper names). Date tokens merged (<em>January 2, 1990</em>  <em>January_2</em>,<em>1990</em>), and number tokens merged.</p>
<p>Number merging, in particular, converts things like <em>four score and seven years ago</em> into a single token <em>four_score_and_seven_years_ago</em> which is marked as a number and whose canonical value is <em>87</em>.</p>
<h3 id="splitting">Splitting</h3>
<p>Dialog acts can be split into separate sentences so that <em>Yes I love you</em> and <em>Yes, I love you</em> and <em>Yes. I love you</em> all become the same input of two sentences - the dialog act <code>~yes</code> and <em>I love you</em>.</p>
<p>Run together words may be split if the composite is not known and the pieces are.</p>
<h2 id="pos-parsing">Pos-parsing</h2>
<p>Pos-Parsing performs classic part-of-speech tagging of the tokens. This means that <em>He flies</em> where <em>flies</em> is a verb in present 3rd person is distinguished from <em>He eats flies</em> where <em>flies</em> is a plural noun.</p>
<p>The system also attempts to parse the sentence to determine things like what is the main subject, main verb, main object, object of a clause or phrase, etc.</p>
<p>For English, which is native to CS, the system runs pos-parsing in two passes. The first pass is execution of rule from <code>LIVEDATA/ENGLISH/POS</code> which help it prune out possible meanings of words. The goal of these rules is to reduce ambiguity without ever throwing out actual possible pos values while reducing incorrect meanings as much as possible.</p>
<p>The second pass tries to determine the parse of the sentence, forcing various pos choices as it goes and altering them if it finds it has made a mistake. It uses a <code>garden path</code> algorithm. It presumes the words form a sentence, and tries to directly find pos values that make it so in a simple way, changing things if it discovers anomalies.</p>
<p>For foreign languages, the system has code that allows you to plug in as a script call things that could connect to web-api pos-taggers. It also can directly integrate with the TreeTagger pos-tagger if you obtain a commerical license for one or more languages from them. Parsing is not done by TreeTagger so while you know part-of-speech data, you don't know roles like mainsubject, mainverb, etc. But some languages come with chunking, which you can also use to mark chunks as concepts.</p>
<h2 id="ontology-marking">Ontology Marking</h2>
<p>Ontology Marking performs a step unique to ChatScript. It marks each word with what alternative views one might have of it. Pattern matching can match not just specific words but any of the alternate views of a word.</p>
<p>A pattern like <code>(I * ~like * ~animals)</code> can match any sentence which has that rough meaning, covering thousands of animals and dozens of words that mean to like. These <code>~</code> words are concept names, and ChatScript can match them just as easily as it can match words.</p>
<p>CS finds concept sets a word belongs to. Concept sets are lists of words and phrases (and concepts) where the words have some kind of useful relationship to each other.</p>
<p>A classic concept set is a synonym of a word. <code>~like</code> is the set of words that mean to like, e.g., <em>admire</em>, <em>love</em>, <em>like</em>, <em>take a shine to</em>, etc.</p>
<p>Another kind of concept set is a property of things like <code>~burnable</code> which lists substances and items that burn readily.</p>
<p>A third concept set kind defines affiliated words, like <code>~baseball</code> has <em>umpire</em>, <em>bat</em>, <em>ball</em>, <em>glove</em>, <em>field</em>, etc. And yet another concept set can define similar objects that are not synonyms, like <code>~role</code> which is the set of all known human occupations.</p>
<p>ChatScript comes with 2000 such sets, and it is easy for developers to create new ones at any time.</p>
<p>Pos-tags like <code>~noun</code>, <code>~noun_singular</code>, and sentence roles like <code>~mainSubject</code> are also concept sets and so the results of pos-tagging merely become marked concept sets attached to a word.</p>
<p>Marking also does the classic lemmatization (finding the canonical root). This includes canonical numbers so a number-merged <em>one thousand three hundred and two</em> which became a single token has the canonical form <em>1302</em> also.</p>
<p>Marking means taking the words of the sentence in order (where they may have pos-specific values) and noting on each word where they occur in the sentence (they may occur more than once).</p>
<p>From specific words the system follows the member links to concepts they are members of, and marks those concepts as occuring at that location in the sentence. It also follows <code>is</code> links of the dictionary to determine other words and concepts to mark. And concepts may be members of other concepts, and so on up the hierarchy. There exist system functions that allow you, from script, to also mark and unmark words. This allows you to correct or augment meanings.</p>
<p>In addition to marking words, the system generates sequences of 5 contiguous words (phrases), and if it finds them in the dictionary, they too are marked.</p>
<div class="figure">
<img src="ontolog.png" alt="ChatScript Ontology" />
<p class="caption">ChatScript Ontology</p>
</div>
<h2 id="script-compiler">Script Compiler</h2>
<p>In large measure what the compiler does is verify the legality of your script and smooth out the tokens so there is a clean single space between each token. In addition, it inserts <code>jump</code> data that allows it to quickly move from one rule to another, and from an <code>if</code> test to the start of each branch so if the test fails, it doesn't have to read all the code involved in the failing branch.</p>
<p>It also sometimes inserts a character at the start of a patttern element to identify what kind of element it is. E.g., an equal sign before a comparison token or an asterisk before a word that has wildcard spelling.</p>
<h1 id="byte-oriented-languages">Byte-oriented languages</h1>
<p>While CS is itself a scripting language, it embeds a couple of other small languages (other than JavaScript) within it.</p>
<p>The POS tagger has 2 mini-languages: one for removing implausible possible pos-tags from words and one for marking POS-tags of words based on idiomatic features. The latter is source in the RAWDICT file conditionalIdioms.txt and the former has source files in the folder LIVEDATA/ENGLISH/POS with interpretation code in englishTagger.cpp via the function ApplyRules.</p>
<p>The query system has its own mini-language for defining fact queries. Data is in LIVEDATA/SYSTEM/queries.txt and scripters can define their own. Execution occurs in infer.cpp .</p>
<h1 id="multiple-bots">Multiple Bots</h1>
<p>ChatScript can run multiple bots in one build. Each bot can own (or share with specific other bots) topics, facts, and functions. This means multiple instances of these things may exist, owned by different bots. A bot in a multi-bot environment has a unique name and unique id. The botmacro defines the name and within it the bot id is declared by assignment to $cs_botid. You define in the filesxxx.txt file what bot name and id is compiling some particular piece of script.</p>
<pre><code>outputmacro: mybot()
$cs_botid = 1</code></pre>
<p>Bot id's are powers of 2 and you are limited to 64 unique bots.</p>
<p>You define who owns a topic using a topic flag or in a bot zone of your filesx.txt. This field is saved with the topic data, with spaces around the bot name so one can do a <code>strstr</code> on that field to see if current bot name is found.</p>
<p>You define who owns a fact normally in the bot zone of your filesx.txt. A fact field has a bot id mask saying which bots may view it. A mask of 0 means all bots can see it. Code that accesses facts uses functions like GetNondeadHead and GetNondeadNext, which walk a fact list ignoring all facts marked as killed or not visible to the current bot (myBot).</p>
<p>You define who owns a function just like a fact and the function data includes the mask. The only caveat is that any botmacro functions must have a 0 value (must be globally visible) in order to allow new users to be launched. Code is stored in TOPIC/BUILDn/macros1.txt (if defined in BUILD1). A sample definition:</p>
<pre><code>^oob o 1 0 B( $_what $_x $_y) $_x = 1 $_y = $_x `</code></pre>
<p>The function name is ^oob.</p>
<p>The <code>o</code> says this is an output macro. <code>t</code> is a tablemacro. <code>d</code> is a dual macro and <code>p</code> is a pattern macro. 'O' and 'P' mean that the function allows variable numbers of arguments up to its actual limit count. Arguments not supplied will be defaulted to null.</p>
<p><code>1</code> is the bot id owning this function.</p>
<p><code>0</code> are any flags on the arguments that specify special processing of incoming values.</p>
<p><code>B</code> is the argument count as the number added to 'A' (i.e. 1 argument). If arguments exceed 15, the base will be 'a' instead with 15 deducted from the index.</p>
<p>The list in parens are the function arguments and any local variables that need to be saved and restored across the call. Following that is the actual compiled script code, ending with a backtick which completes this definition.</p>
<h1 id="private-code">Private Code</h1>
<p>You can add code to the engine without modifying its source files directly. To do this, you create a directory called privatecode at the top level of ChatScript. You must enable the <code>PRIVATE_CODE</code> define.</p>
<p>Inside it you place files:</p>
<p><code>privatesrc.cpp</code>: code you want to add to functionexecute.cpp (your own cs engine functions) classic definitions compatible with invocation from script look like this:</p>
<pre><code>static FunctionResult Yourfunction(char* buffer)</code></pre>
<p>where ARGUMENT(1) is a first argument passed in. answers are returned as text in buffer, and success/failure codes as FunctionResult.</p>
<p><code>privatetable.cpp</code>: listing of the functions made visible to CS table entries to connect your functions to script:</p>
<pre><code>{ (char*) ^YourFunction, YourFunction, 1,0, (char*) help text of your function},</code></pre>
<p><code>1</code> is the number of evaluated arguments to be passed in where <code>VARIABLE_ARGUMENT_COUNT</code> means args evaled but you have to detect the end and <code>ARGUMENT(n)</code> will be <code>?</code></p>
<p>Another possible value is <code>STREAM_ARG</code> which means raw text sent. You have to break it apart and do whatever.</p>
<p><code>privatesrc.h</code>: header file. It must at least declare:</p>
<pre><code>void PrivateInit(char* params);  called on startup of CS, passed param: private=
void PrivateRestart(); called when CS is restarting
void PrivateShutdown();   called when CS is exiting.
privatetestingtable.cpp  listing of :debug functions made visible to CS</code></pre>
<p>Debug table entries like this:</p>
<pre><code>{(char*) &quot;:endinfo&quot;, EndInfo,(char*)&quot;Display all end information&quot;},</code></pre>
<p>There are some hooks you can define to tap into execution of the engine. Use a) PerformChatArguments call at start of PerformChat b) SignalHandler on linux exception c) MongoQueryParams adjustments for document query d) MongoUpsertKeyvalues adds additional params for upsert e) MongoGotDocument invoked if mongo successfully retrieves document f) PerformChatArguments is called on starting user volley processing</p>
<pre><code>Private code should call RegisterHookFunction, typically in PrivateInit, to connect an actual function to a 
hook name.</code></pre>
<h1 id="documentation">Documentation</h1>
<p>Master documentation is in the <code>WIKI</code> folder, with <code>PDFDOCUMENTATION</code> and <code>HTMLDOCUMENTATION</code> generated from that using scripts in <code>WIKI</code>.</p>
</body>
</html>
