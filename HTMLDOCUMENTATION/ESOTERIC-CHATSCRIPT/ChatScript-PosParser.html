<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="chatscript-pos-parser-manual">ChatScript Pos-Parser Manual</h1>
<blockquote>
<p>Copyright Bruce Wilcox, gowilcox@gmail.com</p>
</blockquote>
<p><br> Revision 2/8/2021 cs11.1</p>
<p>How to support non-English languages at end of manual.</p>
<h2 id="perspective-on-state-of-the-art-pos-tagging-and-parsing">Perspective on State of the Art Pos-tagging and Parsing</h2>
<p>Back in school we learned the various parts of speech (noun, verb, adjective, adverb, preposition ...) and were taught basic rules of grammar. Why? To help us understand meaning. But fancy grammar is not needed for basic meaning. <em>Me hungry</em> is perfectly understandable. And context also dictates meaning: <em>What do you like to do?</em> And <em>What food do spiders eat?</em> Can both be answered with <em>fly</em> with entirely different meanings.</p>
<p>And most chatbots, even in ChatScript, don't use pos-tagging or grammar.</p>
<p>They don't understand general meaning but they can hunt for specific meanings by looking for keywords in particular combinations or orders. But ultimately, you can handle more meaning when you can parse a sentence.</p>
<p><em>Pos-tagging</em> (part-of-speech tagging) is a strange beast. Pos-taggers define a range of labels for their convenience which can be more or less than what you'd expect.</p>
<p>I learned something like 8 parts of speech as a child. Pos-taggers vary from 38 possible tags to over a hundred. <em>Existential there</em> is a common pos-tag, as in <em>there is a table</em>. On the more side, pos-taggers typically separate verbs into their various tenses. On the less side, the standard Penn Treebank system lumps prepositions and subordinate conjunctions into the single label IN.</p>
<p>Pos-tagging by itself is often useless. It exists to support parsing. Nowadays most people treat postaggers and parsers as a done deal. A long time ago a guy named Brill was discovered that you can get 90% of words correctly tagged merely by tagging it with its most common tag. Nowadays statistical pos taggers like the Stanford parser are the gold standard and on Wall Street Journal type articles it is said to be about 97.3% accurate in tagging.</p>
<p>Training probability pos-taggers means it generalizes what it has seen to build a relatively simple model of how probable a tag is given surrounding words. You can then test it on the same original data (something you don't normally do with machine learning models) and see how they do. TreeTagger trained on a large sample of Wall Street Journal sentences, achieves 97.5% accuracy on the replay. Trained on the switchboard corpus of telephone conversations yielded 89.7% against those. Pos-tagging degrades rapidly on data it was not trained for. One review said that on bug reports the Stanford Pos-Tagger was between 83.6% and 90.5% accurate using Wall Street Journal trained models.</p>
<p>Another study showed that trained on WSJ data (lots of clean data) and applied to the same kind of data, atis: Recordings of Air Travel Information System dialogue, i.e. natural speech. 2. brown: The original Brown Corpus, containing various topics. 3. swbd: Switchboard Corpus of telephone conversations. 4. wsj/00-05: Wall Street Journal articles (collection 0 to 5). 5. wsj/00-22,24: Wall Street Journal articles (collection 0 to 22, and 24). 6. wsj/23: Wall Street Journal articles (collection 23). wsj/23: Percent Correct: 97.454%</p>
<p>Statistical parsers look at tuples (typically 3) of words to predict what part-of-speech a word will be. And because they do so well, pos-tagging is now separated into a separate phase from parsing. These &quot;good&quot; results are for kinds of material the tagger is trained for and degrades on other works until trained there. They are rarely trained on other kinds of work because the training data isn't there.</p>
<p>Furthermore, there's a fundamental flaw with the idea that each word can be given a correct pos tag. Idioms are not addressed. For example: the idiom <em>until recently</em> is an adverb idiom. Yet under normal pos-taggers it becomes a preposition and an adverb. So where is the object of the preposition? But hey, at least it's one of the words is right.</p>
<p><code>More than</code> is a particularly interesting combo. <em>More than one ate meat</em>. They label <em>more</em> an adjective and <em>than</em> a preposition/conjunction while they correctly label the subject as one and the noun phrase contains a quantifier phrase. What about <em>they sold more than 150 units</em>. The word than is either a preposition or a subordinate conjunction under some pos-taggers. But more than is also an idiom whose composite postag would be as a quantifier.</p>
<p>Quantifiers join articles and determiners as something that comes before a noun (<em>all children</em>) and denote quantity. Then mix that with being allowed to omit words. I love her more than you really means_ I love her more than [I love] you_ and <em>than</em> is a conjunction.</p>
<p>Or <em>by the time we left, we were tired</em>. You take a preposition determiner noun (<em>by the time</em>) but as an idiom it's a subordinate conjunction. CMU's Link Parser recognizes and marks idioms and their behavior correctly. And so does ChatScript. Stanford will collapse some multi-word prepositions into a single one during parsing, but not during pos-tagging. So you end up with strange markings. Another example is <em>inch by inch, they crawled</em>. The pos and tree for that in Stanford is rubbish, starting with noun, preposition, noun.</p>
<p>Back to the idea that Stanford is good doing 97.3% accurate in pos-tagging. 97.3% accuracy in postagging means that out of every 100 words, almost 3 are wrongly tagged. The average sentence length of populist publications like Reader's Digest in 1985 was 20-22 words. Heavy duty publications like the Wall Street Journal or the New York Times averaged around 26-27 words. So presumably almost one in every four WSJ sentences is wrongly tagged. Even if you pos-tag a sentence perfectly you can wrongly parse it. When pos-tagging is wrong, what chance do you have? The stated accuracy of parsing of the Stanford parser is 56%. Almost half of what it reads is parsed incorrectly.</p>
<p>Google recently released SyntaxNet, an even better parser. Yet if you give it <code>wind the clock</code>, it thinks <code>wind</code> is a noun. It doesn't even have a sentence there.</p>
<p>ChatScript faces uncommon problems from most Natural Language tools.</p>
<p>The best taggers/parsers are trained on the Wall Street Journal, where everything is properly cased. If you pass <em>i like you</em> to the Stanford parser, it will tell you that <em>i</em> is a foreign word, <em>like</em> is a preposition, and <em>you</em> is a pronoun.</p>
<p>Chatters often never use upper case and speech recognitions devices don't output it either. So ChatScript works to handle all cases of things. And, following established tradition, I define my own tags for my own convenience. In addition to the usual tags differentiating various kinds of nouns and verb, I also differentiate words based on how it is used. Nouns can be used as adjectives, so bank teller is an adjective_noun noun_singular pair. Verbs can be used as nouns or adjectives, so we have the gerund (walking is fun) and the noun infinitive (to walk is fun) and the adjective participle (the walking dead is dead).</p>
<p>Postagging is harder than it looks. Consider these uses of the word <em>up</em>.</p>
<p><em>what jumps up?</em> # adverb up, pronoun what <br><em>what jumps up the wall</em> # preposition up, pronoun what <br><em>what jumps up the ante?</em> # verb up, determiner what <br><em>what do people jump up?</em> # preposition up, pronoun “what” as object</p>
<p>Hence ChatScript has a built-in pos-tagger/parser using rules of grammar along with statistics. This is the tack taken by <em>Constraint Grammar</em> parsers, which can achieve high degrees of pos-tagging accuracy (99.x%) and run rapidly. Their primary flaw is you have to hand code all the rules of grammar (say around 1500 of them) and need a lot of grammatical expertise. And there are no open-source versions of them.</p>
<h2 id="complaints-about-statistical-pos-parsers-and-stanfords-in-particular">Complaints about statistical pos-parsers and Stanford's in particular</h2>
<p>So one complaint I have is with accuracy. Even on work they are trained on, they reflect probability of words. So they become blind to low probability events. Like <code>I ate everything but my dog</code>. The dictionary tells us that <code>but</code> is usually a coordinating conjunction, but also rarely a preposition. In the sentence above, ML parsers always claim it is a coordinating conjuction, though in fact it is a preposition. And you can't parse this sentence correctly if you are wrong about the part of speech.</p>
<p>Another complaint is speed and memory requirements. The simpler of the Stanford parsers is the PCFG one. On an Intel i5 2.53 Mhz machine, a 27 word sentence takes 1.5 seconds and 100 Mb. ChatScript takes under 10 milliseconds and 50Mb with a full dictionary. You can run with a large dictionary in 16Mb for a cellphone.</p>
<p>And a fourth complaint is that Stanford's system will always return a parse, even if the parse is not reasonable. The parse of <em>is it on me</em>? given that it treats on as an adverb instead of a preposition, is garbage and is similar to <em>is it me</em>? with an extra adverb tacked on. For other sentences it can't say <em>I find no verb so either this isn't a sentence or something is wrong</em>. It has no way of knowing that maybe it failed when sometimes one clearly could if one knew grammar.</p>
<p>My fifth complaint, the output is a tree structure, which then needs to be reinterpreted by some other tool.</p>
<p>And my sixth complaint is that Stanford's errors are uniformly distributed. It doesn't matter if the sentence is a short one, a first grade sentence, whatever. It will make errors in simple sentences as well as complex ones. Particularly for chat, simple sentences are more likely, so I would prefer a pos-tagger that was more accurate on easy stuff.</p>
<p>And my final complaint is that you can't readily fix an ML tagger's mistakes. It has to be trained on a corpus and creating one that will fix issues is hard and not ever done.</p>
<h2 id="interesting-pos-parsing-examples">Interesting Pos-parsing examples:</h2>
<p>The Stanford Parser (and I pick on it merely as representative of all statistical parsers of which it is considered one of the best) is 97.3% accurate in uniform ways. That is, it is flawed on all kinds of input from simple sentences to complex ones. Simple sentences can defeat it. It can handle <em>It is on me</em> but not <em>Is it on me</em>? which becomes: <em>is</em> (verb) <em>it</em> (pronoun) <em>on</em> (adverb) <em>me</em> (pronoun) making on an adverb instead of a preposition.</p>
<p>And it has weird variances: <em>Get it off</em> of me labels <em>off</em> as a particle (correctly) but _get the spider off of me labels <em>off</em> as an adverb (differently and wrongly). Or if you say <em>I saw Dad</em> do it it correctly labels <em>Dad</em> as a proper noun. Same for <em>Father</em> and <em>Mother</em>. But <em>Mom</em> it labels as an ordinary singular noun, even while keeping it capitalized in its output. Or consider <em>my dog is a blue being</em> which it correctly labels <em>blue</em> as an adjective and <em>being</em> as a noun. But <em>my dog is a big blue being</em> it labels <em>blue</em> as a noun and <em>being</em> as a verb phrase present participle.</p>
<p>It is particularly inept at distinguishing pronouns from determiners (always considering them determiners), so it will parse this sentence <em>I'll take all I can get</em> by labelling <em>all</em> as a determiner. Similarly with <em>All she had to do was ask</em>, it treats <em>all</em> as a determiner.</p>
<p>The main sentence should parse to all was ask with an implied that she had to do clause modifying all. And, strangely, the Stanford pos tagger likes to label <em>ago</em> as IN (prepostion or subordinate conjunction), which it never is, instead of adverb like in <em>they lived twenty years ago</em>. I can't even imagine how that error exists in the system. Even the simple <em>Many are poor</em> has <em>many</em> considered a determiner - but there is no noun. And if you say <em>many of them are poor</em> it changes <em>many</em> from a determiner to an adjective. Still no noun anywhere in sight.</p>
<p>It also doesn't handle simple stuff like <em>what swims are safe</em>, considering <em>swim</em> to be a verb. And it generally always thinks <em>can</em> is a modal verb, like in <em>what can goes pop?</em>.</p>
<p>There are also other interesting issues with quantifier phrases. <em>A lot of children eat</em>. Do you want the subject to be <em>lot</em> or <em>children</em>. If <em>a lot</em> of is a quantifier idiom, then the subject is <em>children</em>. If you are doing raw pos-tagging, then the subject is <em>lot</em>. Either will work, but I'd rather have children be the subject. Same for <em>Some of the honey spilled</em>. Normal parses have <em>some</em> is the subject. But that's underinformative. CS treats <em>Some of the</em> as an idiom determiner, so the subject becomes <em>honey</em>.</p>
<p>Consider this sentence: <em>he painted the car purple</em>. The Standford tagger says: <em>he</em>/PRP <em>painted</em>/VBD <em>the</em>/DT <em>car</em>/NN <em>purple</em>/NN which means it claims _purpl_e is a noun. I can live with that, though one might prefer <em>purple</em> be considered an adjective. The parse, however, becomes problematic. Should it be considered <em>subect verb indirectobject object</em> or <em>subject verb objectcomplement</em>. Or is it <em>subject verb directobject</em> (<em>the object being car purple</em>)? Its parse looks just like a parse for <em>he painted the bank teller</em>.</p>
<h2 id="proper-name-merging">Proper name merging</h2>
<p>This gets even messier given that ChatScript will attempt named entity extraction - it will decide some sequences of words represent a single upper-case compound name.</p>
<p>By default ChatScript attempts to detect named entities given as multiple words, and merge them into a single token with underscores. <em>united states of america</em> becomes <em>United_States_of_America</em>. This is not without its hazards. The WORLDDATA ships with a large number of names of works like movies, tv shows, books, etc. These can collide. <em>Don't lie to me</em> can see <em>lie to me</em> as a possible TV show name. The merging code will ALWAYS merge quoted strings and capitalized sequences, so <em>Lie to Me</em> will get merged. It will also merge any sequence whose result is marked with the property ALWAYS_PROPER_NAME_MERGE. Currently world data adds this on to all location names (countries, cities, states) so they are always a single token no matter what case is used. The merging code will not automatically merge the names of TV shows. Nevertheless the sequence will be marked with its appropriate concepts because the system checks sequences of words even if they are not merged. So you would get <em>lie</em> <em>to</em> <em>me</em> <em>Lie to Me</em> all marked appropriately and it is up to the script to distinguish.</p>
<p>I personally run script early on that sees if <code>~NOUN_TITLE_OF_WORK</code> matches. If it does, it determines if it was used in a sentence involving relevant verbs like <em>I watched lie to me yesterday</em> or if the user entered it capitalized or quoted or if we were already in the TV topic. If none of those are true, the script erases the <code>~TV</code> topic mark using <code>^unmark</code>. This prevents the system from erroneously trying the TV topic. You can also just turn off proper name merging by changing the value of <code>$TOKEN</code> removing the <code>| #DO_PROPERNAME_MERGE</code> value usually applied, at the cost of having to deal with named sequences yourself in script.</p>
<h2 id="chatscript-parser">ChatScript Parser</h2>
<p>The ChatScript parser runs by default on all input, doing what it can to parse it. If it believes it failed to parse correctly then it will set the tokenflags appropriately. You can test for this like this:</p>
<pre><code>u: ( %tokenflags&amp;#FAULTY_PARSE)</code></pre>
<p>You can suppress the parser by setting <code>$token</code> to NOT have the request to parse <code>| #DO_PARSE</code> If the parser is not run, then the pos-tags of all words will still be partially performed, reducing the set of word interpretations as much as it can without risking losing any correct pos-tag. But you will not get any parse information..</p>
<p>The fragments of a successful parse are retrievable using concepts. The main sentence, because it may not contiguous and is special, does not have a composite retrieval. Instead you can retrieve <code>~mainsubject</code>, <code>~mainverb</code>, <code>~mainindirect</code>, <code>~maindirect</code>. Things which are contiguous chunks are phrases, clauses, and verbals.</p>
<p>ChatScript has a complexity limit, and will not accept sentences near 255 words. Also, sentences containing more than 7 of some particular concept will not mark after the first 7. So a sentence with 8 nouns will not have a ~noun after the 7th. If the nouns were a mixture of singular and plural, then it will represent them, up to the 7 limit.</p>
<p>ChatScript recognizes these structures: the main sentence, prepositional phrases (called phrases), subordinate clauses (called clauses) and various verbal expressions (called verbals) like gerunds, adjective participles, and noun infinitives.</p>
<p>Parse results are all concepts and are matched just like any other. E.g.,</p>
<pre><code>u: (_~mainsubject * _~mainverb * _~mainobject) A 3 piece sentence in normal order.</code></pre>
<p>See the manual ChatScript System Variables and Engine-defined Concepts for a list.</p>
<p>In addition, you may find ^phrase(type matchvar) useful to retrieve all of a prepositional phrase or a noun phrase. Type is <code>noun</code>, <code>prepositional</code>, <code>verbal</code>, <code>adjective</code>. Optional 3rd argument <code>canonical</code> will return the canonical phrase rather than the original phrase. E.g.,for input:</p>
<pre><code>u: (I ~verb _~directobject) $tmp = ^phrase(noun _0)</code></pre>
<p>with input <em>I love red herring</em> <code>$tmp</code> is set to <em>red herring</em>.</p>
<h2 id="full-sentence-information">Full Sentence Information</h2>
<p>Sentence parse data comes in 3 kinds:</p>
<ol style="list-style-type: decimal">
<li>terminal punctuation - <code>s:</code> <code>?:</code> and <code>\!</code> pattern</li>
<li><p>global data:</p>
<pre><code>%tense %voice %sentence %quotation %impliedyou %impliedsubject %foreign
%command %parsed %question %length
%tense = { past, present, future}
%voice = {active, passive}</code></pre></li>
<li><p>word data- concepts including part of speech and ROLE</p></li>
</ol>
<h2 id="testing-and-development">Testing and development</h2>
<p>There are 2 phases that can intermix. The first are rules that try to remove obviously illegal pos values. These rules are in <code>LIVEDATA/ENGLISH</code>. I have a standard test</p>
<pre><code>:pennmatch raw</code></pre>
<p>which takes a bit above 90K tokens in 3800 pennbank sentences and reports those that have incorrectly pruned (<code>REGRESS/PENNTAGS/penn.txt</code>). It’s goal is to maximally prune while NEVER removing a valid pos-tag. It currently prunes badly 2% of the time and prunes 47K ambiguous words down to 15.7K.</p>
<p>The next phase is hard code parsing. It tries to find a sentence structure that works, using a garden path algorithm. Along the way it can assign pos, rerun rules, assign roles, and sometimes override prior pos decisions when it finds a conflict. It gets run as</p>
<pre><code>:pennmatch</code></pre>
<p>and currently is 94% right in pos-tagging.</p>
<pre><code>:pos this is a sentence</code></pre>
<p>displays what it is doing as it pos/parses.</p>
<h2 id="augmented-english-language-support">Augmented English language support</h2>
<p>TreeTagger has a pos-tagger for English (see Foreign language support about TreeTagger) and if you have a license for it, it works in conjunction with ChatScript's own tagger to yield a better result than either separately. In the bug reports study, TreeTagger performs the best in assigning tags to nouns and verbs, while the Stanford tagger performs the best in assigning tags to adjectives and adverbs. In general I care more about nouns and verbs.</p>
<h2 id="foreign-language-support">Foreign Language support</h2>
<p>While ChatScript supports UTF8 for input and scripting, a lot of ChatScript's power comes from the concise pattern matching code. That, in turn, stems from the ability to define concepts, and to take advantage of ChatScript's dual input stream - original word and lemma (canonical form). So instead of having to write patterns naming all forms of a verb, you can just use the lemma form and mean all of them. Or the singular noun to catch plural as well. That ability depends on pos-tagging abilities.</p>
<p>CS allows you to use an external pos-tagger and/or parser and/or spelling corrector for other languages. It comes with a <em>German</em> simple bot to illustrate how to do this, using TreeTagger. Treetagger is one example you can use (many others exist). TreeTagger has windows, mac, linux versions. TreeTagger supports a wide range of languages for free but you need a license if you want to use it commercially. The local non-commercial copy is annoying in that it outputs a couple of processing status messages as it goes, but it would have no impact if CS is being used as a server, and at least allows you to experiment. I presume the commercial license would enable you to remove them.</p>
<p>http://www.cis.uni-muenchen.de/~schmid/tools/TreeTagger/ (Author: Helmut Schmid, CIS, Ludwig-Maximilians-Universität, Germany).</p>
<p>The German bot assumes you have installed TreeTagger and the german data per instructions provided on his website. I have only tried the Windows installation.</p>
<p>To use a foreign tagger, you set the <code>$cs_externaltag</code> variable in your bot definition to a topic (called in Gambit mode) that will perform the work. And you need to disable ChatScript from performing the work. Make your bot definition <code>$cs_token</code> NOT use the following: <code>#DO_SPELLCHECK</code>, <code>#DO_PARSE</code>, <code>#DO_SUBSTITUTE_SYSTEM</code> (since that is english substitutions and punctuation processing).</p>
<p>In your tagging topic, you invoke your spellchecker, or tagger, or parser, either locally via <code>^popen</code> or remotely using <code>^tcpopen</code> or <code>^jsonopen</code>. And then process the return data and use one or more of these functions to alter ChatScript's internal data.</p>
<p><code>^setcanon</code>(wordindex value) - changes the canonical value for this word <br><code>^settag</code>(wordindex value) - changes the pos tag for the word <br><code>^setoriginal</code>(wordindex value) - changes the original value for this word <br><code>^setrole</code>(wordindex value) - changes the parse role for this word</p>
<p>The first important one is ^setcanon, to allow the CS dual input processing to work in patterns. If you are doing spell checking, you may use <code>^setoriginal</code> to revise the original word. SetTag and SetRole are for the pos value and Role value (mainsubject, mainverb, etc). These values will come back in whatever notation your external system uses. All of this happens BEFORE Chatscript starts marking things and therefore if you use <code>:trace</code> prepare, you can see the results of the annotations in the concepts triggered.</p>
</body>
</html>
