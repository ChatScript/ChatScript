<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>ChatScript-Exotica-Examples</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height; auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="chatscript-exotica-examples">ChatScript Exotica Examples</h1>
<blockquote>
<p>9/17/2013 CS 3.62</p>
</blockquote>
<h2 id="setrejoinder"><code>^SetRejoinder</code></h2>
<p>Normally the rejoinder is script immediately after the executed
gambit or responder or rejoinder. But if you want to direct the system
to be elsewhere, you can use SetRejoinder to do that. Below is an
example wherein the normal rejoinders are set to cover a small robot’s
rejoinders to the dangers of getting wet.</p>
<pre><code>t: REJOIN() If you poured coffee over me or let me fall into the bathtub what do you think would happen?
  #! why
  a: (~why) I want you to think about and understand my vulnerabilities.
  
  #! get wet
  a: (wet) And then? ^setRejoinder(REJOIN)

  #! short out
  a: (short) Yes.

  #! die
  a: ([die deactivate destroy ruin]) Precisely.</code></pre>
<p>If the human replies: <em>you’d die</em>, we go directly to
<em>precisely</em>. But if the user replied <em>you’d get wet</em>, we
can ask for a more thought out answer by saying <em>and then</em> and if
the user then replies with <em>you’d short out or die</em> we get the
app.</p>
<h2 id="settokenflags"><code>^SetTokenFlags</code></h2>
<p>Tokenflags are set by the engine for things it detects, like question
marks and exclamations. But the engine cannot detect all forms of
questions and there are maybe things you want treated as questions which
are actually statements.</p>
<p><em>Tell me about birds</em> is very similar in spirit to <em>what do
you know about birds</em>, for example, yet one is a statement (a
command) and one is a question. If you want to extend the system marking
of questions for your own purposes, you can. You would just write a
topic filled with appropriate rules and call it from your control script
before you do other things that might actually generate output. Below is
a sample rule from such a topic:</p>
<pre><code>#! Tell me about birds.
u: (&lt; [~describe ~list ~explain]) SetTokenFlags(#QUESTIONMARK)</code></pre>
<p>After this rule executes, no output is generated so it doesn’t
disturb other topics. But the question flag is now on, so a rule in a
later topic like:</p>
<pre><code>?: (bird) What about birds?</code></pre>
<p>Will now react if the input is <em>tell me about birds</em></p>
<p>Note that the change will not impact rule matching within the topic
you have just done the change, because it has commited the set of rules
it will try to match. So it only applies to later topics.</p>
<h2 id="passing-in-parameters">Passing in parameters</h2>
<p>When you want to send in avatar data or other data, there is a notion
of “out-of-band” communcation. The standard way (arbitrary) is to
include the information at the front of the input, with
<code>[ ]</code>. This can then be parsed out in various ways depending
on how you want. If you are setting variables, for example, here is code
for that:</p>
<pre><code>u: (\[ _* \] _*) # grab params and main sentence - a param looks like location:100
    @0 = ^burst(&#39;_0 &quot; &quot;) # get all variable assigns as facts
    loop() # do a precise count
        {
        $$tmp = first(@0subject) # pick off next param
        _2 = ^burst($$tmp :) # split word and value
        _2 = ^join($ _2) # create variable
        ^_2 = _3 # do assignment onto variable
        }
    if (_1) # CS breaks off the leading [] as its own sentence. So will be null
        {
        input(&#39;_1)
        fail(sentence) # do sentence without params
        }</code></pre>
<h2 id="pseudoparsing">PseudoParsing:</h2>
<p>Suppose you get input like</p>
<p><em>John is taller than Mary and Mary is taller than Sue. Who is
shorter, John or Sue?</em></p>
<p>Anyone can write rules to handle that specific question. The trick is
to write few rules that are general. The following esoteric use of
ChatScript illustrates principles and functions for behaving a bit like
a parser. The goal is to handle incoming data in one or more sentences,
across one or more volleys, and locally handling pronoun references.
This includes as input:</p>
<p><em>Tom is taller than Mary who is taller than Sarah. <br>Tom is
fatter than Joan but she is thinner than Harry. <br>Tom is taller than
Mary but shorter than Sarah. <br>Tom is taller than Mary. Sarah is
shorter than Tom.</em></p>
<p>The code below handles acquiring the facts (not answering the
questions) but organizes the data for easy retrieval. It aims for
generality. The tricks involve how ChatScript manages pattern matching.
Stage one is to preprocess the input to mark in the dictionary where
every word and ALL of its concept and dictionary inheritances occur in
the sentence.</p>
<p>So if word 1 of the sentence is <em>tiger</em>, then <em>tiger</em>
and <em>animal</em> and <em>mammal</em> and <code>~animals</code> and
<code>~zoo</code> might all get marked as occurring at word 1. So when a
pattern tries to match, it can find any of those as being at position 1.
But script can also mark word positions, and it can unmark them as well.
So the FACTER rule matches a series of items and after creating a fact
of them, erases their mark so a rescan of the same rule can try to find
a new series of items.</p>
<pre><code>concept: ~extensions (and but although yet still)
concept: ~than (then than)

topic: ~compare_test system repeat ()

# set local pronoun
s: ( ~propername * [who she he]) refine()
  a: ( _~propername *~2 _who ) $$who = ‘_0
  a: ( _~femalename * _she ) $she = ‘_0
  a: ( _~malename * _he ) $he = ‘_0

# resolve pronouns
s: ( [who she he]) refine()
  a: ( _who $$who) mark(~propername _0)
  a: ( _he $he) mark(~propername _0)
  a: ( _she $she) mark(~propername _0)

s: ( _~propername * ~propername *~2 _~extensions {be} {less more} ~adjective ~than ~propername)
  mark(~propername _1 ) $$and = ‘_0
  
#! Tom is more tall than Mary
#! Tom is taller than Mary and Tom is shorter than Joan.
#! Tom is less tall than Mary
#! Tom is taller than harry but shorter than Joan.
s: FACTER ( _~propername {be} {more} _{less least} _~adjective ~than _~propername )
  $$order = 1
  if (_1) { $$order = $$order * -1 } # flip order
  if ($adj)
  {
   if ($adj != _2 ) # they differ
   {
   if (query(direct_svo _2 opposite $adj ) ) # its the opposite
   {
   $$order = $$order * -1 # flip order
   }
   else {$adj = null} # accept new adjective
   } 
  }

  # adjust pronouns
  if (_0 == who) { _0 = $$who}
  else if (_0 == he) { _0 = $he}
  else if (_0 == she) { _0 = $she}
  else if (_0 ? ~extensions) { _0 = $$and}

  if (_2 == who) { _2 = $$who}
  else if (_2 == he) { _2 = $he}
  else if (_2 == she) { _2 = $she}
  
  if (!$adj)
  {
   $adj = _2
   if ($$order == 1) { ^createfact(_0 $adj _3)}
   else {^createfact(_3 $adj _0)}
  }
  else # already have an adjective to run with
  {
   if ($$order == 1)
   {
   ^createfact(_0 _2 _3)
   }
   else
   {
   ^createfact(_3 $adj _0)
   }
  }

  unmark( ~propername _0)
  unmark(~adjective _2 )
  unmark(~propername _3 )
  $$who = _3
  retry()</code></pre>
<p>A responder for handling questions given 2 people is:</p>
<pre><code>#! who is taller, Tom or Harry?
#! Of Tom and harry, who is taller?
#! who is less tall, Tom or Harry?
#! who is the taller of Mary and Harry
#! Of Tom and harry, who is least tall?
?: COMPARE ([which who what] be {the} {more most} _{less least} _~adjective &lt; * _~propername {and or } _~propername)
  # 0=less 1=adj 2 = person1 3 = person2
  $$order = 1
  if (_0) { $$order = $$order * -1 } # flip order
  if ($adj) 
  {
   if ($adj != _1 and query(direct_svo _1 opposite $adj ) ) # they differ
   {
   $$order = $$order * -1
   }
  }

  # find if _3 is more than _2
  nofail(RULE eval(query(direct_vo ? $adj _2))) # who is taller than _2
  _7 = @0subject
  loop()
  {
   if (_7 == _3) {FAIL(rule)} # now matched
   query(direct_vo ? $adj _7) # who is taller than this
   _7 = @0subject
  }
  
  if ( $$order == 1) # normal order
  {
   if (@0subject) {_3 is.}
   else {_2 is.}
  }
  else # inverse order
  {
   if (@0subject) {_2 is.}
   else {_3 is.}
  }</code></pre>
<p>The system builds facts in a specific order, like (X taller Y) and if
a shorter comes first it flips the order and rewrites using common
adjective notation.</p>
</body>
</html>
