<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>ChatScript-Advanced-Concept-Manual</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height; auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="chatscript-advanced-concept-manual">ChatScript Advanced Concept
Manual</h1>
<p>Copyright Bruce Wilcox, gowilcox@gmail.com
www.brilligunderstanding.com<br></p>
<h1 id="advanced-concepts">ADVANCED CONCEPTS</h1>
<h2 id="concept-exclusion">Concept Exclusion</h2>
<p>In basic chatscript we learned you can build concepts by augmentation
(out of concepts), like</p>
<pre><code>concept: ~animals (~birds ~dogs otter)</code></pre>
<p>You can also build concepts using exclusion, like</p>
<pre><code>concept: ~animals (~birds ~dogs otter !robin)</code></pre>
<p>This concept includes all birds except the robin. Using !, you can
tell CS that certain words are not members of a concept, even though
they may have been added elsewhere in the declaration either directly or
via inclusion of some concept. You can also use ! with concepts to
remove all members of a concept. E.g.</p>
<pre><code>concept: ~wildanimals (!~pet_animals ~animals)</code></pre>
<p>Animals which are pets are not considered wild, so here is a clean
declaration of that.</p>
<h2 id="fundamental-meaning-keywords">Fundamental Meaning Keywords</h2>
<p>Fundamental meaning is the basic minimal form of the sentence without
all the embellishments of phrases, verbals, clauses, adjectives, and
adverbs. Your fundamental sentence consists of main subject, main verb,
and optional main object. The absolute minimal sentence always has a
main verb. In the case of “Go”, we have a command verb and implied
subject “you”.</p>
<p>Fundamental meaning consists of an actor, an action, and an optional
actee. In the active voice sentence “I love you”, the actor is “I”, the
action is “love”, and the actee is “you”. In the passive voice sentence
“I was arrested”, there is no actor, the verb is “arrested”, and the
actee is “I”. Wherease in the passive voice sentence “I was arrested by
the police”, the actor is “police”.</p>
<p>Fundamental meaning patterns always have a verb, which as a keyword
is designated as<br />
“|arrest|” or whatever word or concept you want to detect. A pattern
which includes a fundamental actor is shown as<br />
“~pronoun|arrest|”. One that includes an actee is “|arrest|~police”,
whereas one that has both actor and actee is
“<sub>pronoun|arrest|</sub>police”. So one can write:</p>
<pre><code>concept: ~crimeverbs (arrest convict imprison steal)
topic: ~crimesentences (|~crimeverbs|)</code></pre>
<p>For command sentences, the implied subject is always “you”, so you
can write:</p>
<pre><code>concept: ~me_told_go (you|~movement_verbs|)</code></pre>
<p>Note: these keywords can only be recognized if the system’s parser
can manage to parse out the main subject, main verb, and main object of
the input sentence. This works well for relatively simple sentences.</p>
<h2 id="patterns-as-keywords">Patterns as Keywords</h2>
<p>Instead of just words and phrases, you can also write a pattern in
quotes as a member.</p>
<pre><code>concept: ~leaving( sayonara &quot;(going home now)&quot; exiting)
u: (I *~2 ~leaving)</code></pre>
<p>You are allowed to use any of the pattern elements excepting RETRY
but including “(<span
class="math inline"><em>t</em><em>e</em><em>s</em><em>t</em><em>i</em><em>n</em><em>g</em>!</span>testval)”.</p>
<p>Where the pattern is considered marked will depend on the pattern. If
the pattern has match variable memorization, it will mark where the
first such memorization happened. If the pattern consists of no words
(like the variable testing pattern above), then the concept will be
marked at word 1 of the sentence. Otherwise, if the pattern is has a
normal collection of words, the mark will cover the range of the first
thru last word element that matched. For our leaving example above, if
the input is “I am going home now, see you tomorrow”, then ~leaving
marks words 3-5 of the sentence.</p>
<p>The function ^pick, which can grab a random member of a concept, will
skip over all patterns and just return a word or phrase.</p>
<h2 id="additional-data-on-concepts">Additional data on concepts</h2>
<p>Concepts can have part of speech information attached to them (using
<code>dictionarysystem.h</code> values). Eg.</p>
<pre><code>concept: ~mynouns NOUN NOUN_SINGULAR (boxdead foxtrot)
concept: ~myadjectives ADJECTIVE ADJECTIVE_BASIC (moony dizcious)</code></pre>
<p>Since the script compile issues warning messages on words it doesn’t
recognize, in case you misspelled them, you can also add
<code>IGNORESPELLING</code> as a flag on the concept:</p>
<pre><code>concept: ~unknownwords IGNORESPELLING (asl daghh)</code></pre>
<p>and you can combine pos declarations and ignorespelling. This is
applied recursively to any concepts that are members of this concept.
That may be a bit excessive.</p>
<p>Rather than assigning parts of speech you can recursively limit a
concept’s words to a part of speech using <code>ONLY_NOUNS</code>,
<code>ONLY_VERBS</code>, <code>ONLY_ADJECTIVES</code>, or
<code>ONLY_ADVERBS</code>.</p>
<pre><code>Concept: ~verbs ONLY_VERBS (sit sleep)</code></pre>
<p>This will not react to noun meanings of sleep. The current ontology
files for verbs, adverbs, and adjectives all have the appropriate
<code>ONLY</code> marked on them.</p>
<p>When you don’t want a member concept marked as a consequence, you can
use <code>ONLY_NONE</code> to block propogate. Thus:</p>
<pre><code>concept: ~verbs ONLY_VERBS (~active_verbs sit)
concept: ~active_verbs ONLY_NONE (sleep)</code></pre>
<p>will prevent sleep from being required to be a verb form. Note that
verb forms do not include verbs used as nouns (ie gerunds).</p>
<p>Normally if you declare a concept a second time, the system considers
that an error. If you add the marker <code>MORE</code> to its
definition, it will allow you to augment an existing list.</p>
<pre><code>concept: ~city MORE (Tokyo)</code></pre>
<p>Normally concepts (and topics) discard repeated keywords. For
concepts, you can force it to allow repeats using
<code>DUPLICATE</code></p>
<pre><code>concept: ~mapword DUPLICATE (year month day year month day) # the concept has 6 members</code></pre>
<p>Concepts can be built from other concepts that do not have specific
words.</p>
<pre><code>Concept: ~myconcept (!thisword ~otherconcept)</code></pre>
<p>Note: the system has two kinds of concepts.</p>
<ul>
<li><p><em>Enumerated</em> concepts are ones formed from an explicit
list of members. Stuff in definitions of <code>concept: ~xxx()</code>
are that.</p></li>
<li><p>There are also <em>internal</em> concepts (dynamic concepts)
marked by the system. These include part of speech of a word (requires
using the pos-tagger to decide from the input what part of speech it was
of possibly several), grammatical roles, words from infinite sets like
<code>~number</code> and <code>~placenumber</code> and
<code>~weburl</code>, and so forth.</p></li>
</ul>
<p>The ? operator has two forms. <code>xxx?~yyy</code> will look for
actual membership in the set whereas <code>_n?~yyy</code> will only see
if the location of match detection of _n is the same as a corresponding
match location for the concept. If the concept has not been marked, then
obviously no match is found.</p>
<p>In a pattern of some kind, if you are referencing a sentence location
using a match variable, you can match both kinds enumerated and dynamic
concepts. But if you are not tied to a location in a sentence, you can’t
match internally computed ones. So something like</p>
<pre><code>if ( pattern 23?~number )</code></pre>
<p>will fail. Even</p>
<pre><code>if ( pattern practical?~adjective )</code></pre>
<p>will fail given that deciding practical is an adjective (it could
also be a noun) hasn’t been performed by pos-tagging.</p>
<p>All internal concepts are members of the concept
<code>~internal_concepts</code>.</p>
<h2 id="alternate-ways-of-populating-a-concept">Alternate ways of
populating a Concept</h2>
<p>Normally concepts are an enumeration set you define like this:</p>
<pre><code>concept: ~myconcept (word1 word2 &quot;phrase of mine&quot;)</code></pre>
<p>But you can also extend a concept merely by creating facts:</p>
<pre><code>    $_tmp = ^createfact(word3 member ~myconcept)</code></pre>
<p>Concept membership is actually represented by facts of the above
form.</p>
<p>A third way does not actually create members of a concept and does
not require mere words and phrases. You can use any pattern whatsoever.
And you cannot list it like you would normal members of a concept. You
meremly execute a rule early on in your script that marks places in a
sentence.</p>
<pre><code>u: FAKEIT ( _(find * way)) ^mark(~myconcept _0)</code></pre>
<p>The above detects a pattern, records the location start and end of it
so that you can then mark where in the sentence ~myconcept will now be
detected by any future patterns of yours.</p>
<h2 id="performance">Performance</h2>
<p>Using concepts in patterns is “free”, as is</p>
<pre><code>    if (_0 ? ~concept)</code></pre>
<p>but</p>
<pre><code>    if ($word ? ~concept)</code></pre>
<p>runs linear with number of concept members, so it should be avoided
for large concepts. Pattern matching with concepts/match_variables has
all its overhead cost paid for during marking so there is no real cost
later. And that marking overhead is trivial.</p>
</body>
</html>
