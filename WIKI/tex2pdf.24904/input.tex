\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{long table}}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\date{}

\begin{document}

\section{ChatScript Fact Manual}\label{chatscript-fact-manual}

Copyright Bruce Wilcox, gowilcox@gmail.com www.brilligunderstanding.com
Revision 4/18/2021 cs11.3

\begin{itemize}
\tightlist
\item
  \href{ChatScript-Fact-Manual.md\#simple-facts}{Simple Facts}
\item
  \href{ChatScript-Fact-Manual.md\#advanced-facts}{Advanced Facts}
\item
  \href{ChatScript-Fact-Manual.md\#esoteric-facts}{Esoteric Facts}
\end{itemize}

\section{SIMPLE FACTS}\label{simple-facts}

Facts are triples of \emph{subject}, \emph{verb}, \emph{object} - though
those are just the names of the fields and may or may not be their
content. Facts look like this:

\begin{verbatim}
(Bob eat fish )
\end{verbatim}

The system has a number of facts it comes bundled with and others can be
created and stored either from compiling scripts, or from interactions
with the user.

Facts can use words, numbers, or other facts as field values,
representing anything.

You can build records, arbitrary graphs, treat them as arrays of data,
etc.

\subsection{Simple Creating Facts}\label{simple-creating-facts}

\subsubsection{\texorpdfstring{\texttt{\^{}createfact}( subject verb
object
)}{\^{}createfact( subject verb object )}}\label{createfact-subject-verb-object}

this creates a fact triple. The system will not create duplicate facts.
If you have a fact (Bob eat fish) then executing

\begin{verbatim}
^createfact(Bob eat fish)
\end{verbatim}

will do nothing further (but it will return the found fact). One way to
create a fact of a fact is as follows:

\begin{verbatim}
^createfact( (Bob eat fish) how slowly )
\end{verbatim}

The other way is to assign the value of fact creation to a variable and
then use that variable. You need to pass in a flag at creation, to tell
the system the value is a factid.

\begin{verbatim}
$fact = ^createfact( Bob own fish)
^createfact ($fact Bob pet FACTSUBJECT)

$fact = ^createfact( Bob own dog)
^createfact ($fact Bob pet FACTSUBJECT)
\end{verbatim}

The above creates facts which are findable by querying for pets Bob has.
You can have any number of flags at the end. Flags include:

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.21\columnwidth}\raggedright\strut
flag\strut
\end{minipage} & \begin{minipage}[b]{0.61\columnwidth}\raggedright\strut
description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{FACTSUBJECT}\strut
\end{minipage} & \begin{minipage}[t]{0.61\columnwidth}\raggedright\strut
apply to storing fact ids in the subject field\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{FACTVERB}\strut
\end{minipage} & \begin{minipage}[t]{0.61\columnwidth}\raggedright\strut
apply to storing fact ids in the verb field.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{FACTOBJECT}\strut
\end{minipage} & \begin{minipage}[t]{0.61\columnwidth}\raggedright\strut
apply to storing fact ids in the object field.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{FACTTRANSIENT}\strut
\end{minipage} & \begin{minipage}[t]{0.61\columnwidth}\raggedright\strut
the fact will disappear at the end of this volley\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{FACTDUPLICATE}\strut
\end{minipage} & \begin{minipage}[t]{0.61\columnwidth}\raggedright\strut
allow this fact to be a duplicate of an existing fact.This is
particularly important if you go around deleting facts that might be
referred to by other facts. Those other facts will also get deleted.So
if you want complete isolation from facts that look the same in some
subfact but shouldn't be shared, you'll want that subfact declared
\texttt{FACTDUPLICATE}.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{AUTODELETE}\strut
\end{minipage} & \begin{minipage}[t]{0.61\columnwidth}\raggedright\strut
on a normal fact means that when that fact is destroyed, if it refers to
other facts (FACTSUBJECT, FACTVERB, FACTOBJECT) then those referred
facts will also get destroyed. \texttt{AUTODELETE} on a json fact tells
the system that the value stored as the object field is actually a
normal fact id value and that fact should be destroyed when the json
fact is destroyed.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\subsection{Accessing Facts}\label{accessing-facts}

To find facts, you need to make a query. There can be many different
kinds of queries.

\subsubsection{\texorpdfstring{\texttt{\^{}findfact}( subject verb
object
)}{\^{}findfact( subject verb object )}}\label{findfact-subject-verb-object}

The simplest fact find involves knowing all the components (meanings)
and asking if the fact already exists. If it does, it returns the index
of the fact. If it doesn't it returns \texttt{FAILRULE\_BIT}.

\subsubsection{\texorpdfstring{\texttt{\^{}query}( kind subject verb
object
)}{\^{}query( kind subject verb object )}}\label{query-kind-subject-verb-object}

The simplest query names the kind of query and gives some or all of the
field values that you want to find. Any field value can be replaced with
\texttt{?} which means either you don't care or you don't know and want
to find it.

The kinds of queries are programmable and are defined in
\texttt{LIVEDATA/SYSTEM/queries.txt} (but you need to be really advanced
to add to it). The simplest query kinds are:

\begin{longtable}[]{@{}ll@{}}
\toprule
query flag & description\tabularnewline
\midrule
\endhead
\texttt{direct\_s} & find all facts with the given
subject\tabularnewline
\texttt{direct\_v} & find all facts with the given verb\tabularnewline
\texttt{direct\_o} & find all facts with the given object\tabularnewline
\texttt{direct\_sv} & find all facts with the given subject and
verb\tabularnewline
\texttt{direct\_so} & find all facts with the given subject and
object\tabularnewline
\texttt{direct\_vo} & find all facts with the given object and
verb\tabularnewline
\texttt{direct\_svo} & find all facts given all fields (prove that this
fact exists)\tabularnewline
\bottomrule
\end{longtable}

If no matching facts are found, the query function returns the RULE fail
code.

\begin{verbatim}
?: (do you have a dog) ^query( direct_svo I own dog) Yes.
\end{verbatim}

If the above query finds a fact \texttt{(I\ own\ dog)} then the rule
says yes. If not, the rule fails during output. This query could have
been put inside the pattern instead.

Note: if an argument to a query is a concept name, it will be expanded
to all its constituent members unless you put a quote in front of it.
You probably want this:

\begin{verbatim}
@0 = ^query(direct_vo ? member '~conceptname)
\end{verbatim}

\subsubsection{\texorpdfstring{\texttt{\^{}query}(kind subject verb
object count fromset toset propagate
match)}{\^{}query(kind subject verb object count fromset toset propagate match)}}\label{querykind-subject-verb-object-count-fromset-toset-propagate-match}

Query can actually take up to 9 arguments. Default values are
\texttt{?}. The count argument defaults to \texttt{-1} and indicates how
many answers to limit to. When you just want or expect a single one, use
\texttt{1} as the value.

\texttt{fromset} specifies that the set of initial values should come
from the designated factset. Special values of fromset are \texttt{user}
and \texttt{system} which do not name where the facts come from but
specify that matching facts should only come from the named domain of
facts.

\texttt{toset} names where to store the answers.

Commonly you don't name it because you did an assignment like
\texttt{@3\ =\ \^{}query(...)} and if you didn't do that, \texttt{toset}
defaults to \texttt{@0} so

\begin{verbatim}
if ( ^query(direct_s you ? ?) )
\end{verbatim}

puts its answers in \texttt{@0}. It is equivalent to:

\begin{verbatim}
if ( ^query(direct_s you ? ? -1 ? @0) )
\end{verbatim}

The final two arguments only make sense with specific query types that
use those arguments. A query can also be part of an assignment
statement, in which case the destination set argument (if supplied) is
ignored in favor of the left side of the assignment, and the query
doesn't fail even if it finds no values. E.g.

\begin{verbatim}
@2 = ^query(direct_sv I love you)
\end{verbatim}

The above query will store its results (including no facts found) in
\texttt{@2}.

Queries can also be used as test conditions in patterns and if
constructs. A query that finds nothing fails, so you can do:

\begin{verbatim}
u: ( dog ^query(direct_sv dog wants ?)) A dog wants @0object.
\end{verbatim}

You can also do \texttt{!\^{}query}. Or

\begin{verbatim}
if (^query(direct_vo ? want toy)) {@0subject wants a toy.}
\end{verbatim}

\subsection{Private queries}\label{private-queries}

You can define your own queries beyond the LIVEDATA ones. In a normal
topic file as a top level unit you can do:

\begin{verbatim}
query: name "value"
\end{verbatim}

Name is the name to give your query and the query command string is
placed within double quotes.

\subsection{System-reserved verbs}\label{system-reserved-verbs}

The system builds the Word-net hierarchy using the verb \texttt{is},
with the lower-level (more specific) word as subject and the upper-level
word as object. E.g.

\begin{verbatim}
(dog~1 is animal~4)
\end{verbatim}

The system builds concept and topic sets using the verb \texttt{member}
with the member value as subject and the set name as object. E.g.

\begin{verbatim}
 (run member ~movementverbs)
\end{verbatim}

When you build a table and a data member has a short-form like
\emph{Paris} for *Paris,\_France*, the verb is also \texttt{member} with
subject as short form and long form as object. E.g.,

\begin{verbatim}
(Paris member Paris,_France)
\end{verbatim}

\subsection{@Fact-Sets}\label{fact-sets}

The results of queries are stored in a \emph{fact-set}.

Fact-sets are labeled \texttt{@0}, \texttt{@1}, etc. through
\texttt{@20}.

By default in the simplest queries, the system will find all facts that
match and store them in fact-set \texttt{@0}.

A fact set is a collection of facts, but since facts have fields (are
like records), it is also valid to say a factset is a collection of
subjects, or verbs, or objects. Therefore when you use a factset, you
normally have to specify how you want it used.

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.18\columnwidth}\raggedright\strut
fields\strut
\end{minipage} & \begin{minipage}[b]{0.16\columnwidth}\raggedright\strut
description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.18\columnwidth}\raggedright\strut
\texttt{@1subject}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
means use the subject field\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright\strut
\texttt{@1verb}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
means use the verb field\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright\strut
\texttt{@1object}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
means use the object field\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright\strut
\texttt{@1fact}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
means keep the fact intact (a reference to the fact) - required if
assigning to another set.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright\strut
\texttt{@1+}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
means spread the subject,verb,object onto successive match variables -
only valid with match variables\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright\strut
\texttt{@1-}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
means spread the object,verb,subject onto successive match variables-
only valid with match variables\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.18\columnwidth}\raggedright\strut
\texttt{@1all}\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
means the same as \texttt{@1+}, spread subject,verb,object,flags onto
match variables.\texttt{\_6\ =\ \^{}first(@1all)} - this puts subject in
\texttt{\_6}, verb in \texttt{\_7}, object in \texttt{\_8}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

It is legal to store \texttt{null} into a factset, and it will generally
return \texttt{null} for all accesses of that fact.

\begin{verbatim}
 ?: (do you have a pet ^query( direct_sv I pet ?) ) I have a @0object.
\end{verbatim}

If the chatbot has facts about what pets it has stored like
\texttt{(I\ pet\ dog)} and \texttt{(I\ pet\ cat)}, then the rule can
find them and display one of them. Which one it shows is arbitrary, it
will be the first fact found.

You can transfer the contents of one fact-set to another with a simple
assignment statement like

\begin{verbatim}
@2 = @1
\end{verbatim}

You can transfer fields of a fact from a fact-set using assignment,
while simultaneously removing that fact from the set. The functions to
do this are:

\subsubsection{\texorpdfstring{\texttt{\^{}first}( fact-set ),
\texttt{\^{}last}( fact-set ), \texttt{\^{}pick}( fact-set
)}{\^{}first( fact-set ), \^{}last( fact-set ), \^{}pick( fact-set )}}\label{first-fact-set-last-fact-set-pick-fact-set}

\texttt{\^{}first} - retrieve the first fact, \texttt{\^{}last} -
retrieve the last fact, \texttt{\^{}pick} - retrieve a random fact, e.g.

\begin{verbatim}
_1 = ^first(@1all)
\end{verbatim}

Removing the fact is the default, but you can suppress it with the
optional second argument \texttt{KEEP}, e.g.

\begin{verbatim}
_1 = ^last(@1all KEEP) 
\end{verbatim}

gets the last value but leaves it in the set.

You can erase the contents of a fact-set merely by assigning null into
it.

\begin{verbatim}
@1 = null
\end{verbatim}

This does not destroy the facts; merely the collection of them. You can
sort a fact set which has number values as a field

\subsubsection{\texorpdfstring{\texttt{\^{}sort}( fact-set \{more
fact-sets\}
)}{\^{}sort( fact-set \{more fact-sets\} )}}\label{sort-fact-set-more-fact-sets}

the fact set is sorted from highest first. By default, the subject is
treated as a float for sorting. You can say something like
\texttt{@2object} to sort on the object field. You can add additional
factsets after the first, which will move their contents slaved to how
the first one was rearranged. Eg.

\begin{verbatim}
^sort(@1subject @2 @3)
\end{verbatim}

will perform the sort using the subject field of \texttt{@1}, and then
rearrange \texttt{@2} and \texttt{@3} in the same way (assuming they
have the same counts). If you actually want to destroy facts, you can
query them into a fact-set and then do this:

\subsubsection{\texorpdfstring{\texttt{\^{}delete}( fact-set
)}{\^{}delete( fact-set )}}\label{delete-fact-set}

\begin{verbatim}
^delete(@1)
\end{verbatim}

all facts in \texttt{@1} will be deleted and the set erased. You can
also delete an individual fact whose id is sitting on some variable

\begin{verbatim}
^delete($$f)
\end{verbatim}

If you merely want to empty a factset, you do

\begin{verbatim}
@0 = null
\end{verbatim}

which does not damage any facts. When you do

\begin{verbatim}
^delete(@0)
\end{verbatim}

you delete all facts within that factset AND all facts which use those
facts as part of themselves. Deleted facts are never saved at the end of
a volley.

Normally you will be blocked from deleting system facts (ones created by
a :build and not by execution of your script). But \^{}delete(@1 boot)`
will allow you to do that. Deleted system facts cannot have their space
reclaimed (other than by system restart).

\subsubsection{\texorpdfstring{\texttt{\^{}length}( fact-set
)}{\^{}length( fact-set )}}\label{length-fact-set}

If you want to know how many facts a fact-set has, you can do this:

\begin{verbatim}
^length(@1)
\end{verbatim}

outputs the count of facts.

\subsubsection{\^{}nth(fact-set count)}\label{nthfact-set-count}

If you want to retrieve a particular set fact w/o erasing it, you can
use

\begin{verbatim}
^nth(@1 count)
\end{verbatim}

where the first argument is like \texttt{\^{}first} because you also
specify how to interpret the answer) and the second is the index you
want to retrieve. An index out of bounds will fail.

\subsubsection{\texorpdfstring{\texttt{\^{}unpackfactref}}{\^{}unpackfactref}}\label{unpackfactref}

examines facts in a set and generates all fact references from it. That
is, it lists all the fields that are themselves facts.

\begin{verbatim}
@1 = ^unpackfactref( @2)
\end{verbatim}

All facts which are field values in @2 go to @1. You can limit this:

\begin{verbatim}
@1 = ^unpackfactref(@2object)
\end{verbatim}

only lists object field facts, etc. Unlike variables, which by default
are saved across inputs, fact sets are by default discarded across
inputs. You can force a set to be saved by saying:

\begin{verbatim}
^enable(write @9) # force set to save thereafter
^disable(write @9 ) # turn off saving thereafter
\end{verbatim}

You can store a fact in a fact set easily.

\begin{verbatim}
$$tmp = createfact(I love you)
@0 = $$tmp
\end{verbatim}

or

\begin{verbatim}
@0 += $$tmp
\end{verbatim}

\subsection{Fact Indexing}\label{fact-indexing}

A fact like \texttt{(bird\ eat\ worm)} is indexed by the system so that
bird can find facts with bird as the subject or as the verb or as the
object. Similarly eat can find facts involving it in each position. As a
new fact is added, like \texttt{(bird\ hate\ cat)} the word bird gets
the new fact added to the front of its list of facts involving bird in
the subject field.

So if you search for just one fact where bird is the subject, you get
the most recent fact. If you search for all facts with bird as the
subject, the facts will be stored in a fact set most recent first
(lowest/earliest element of the fact set).

You would use \texttt{\^{}first(@2)} to get its most recent fact and
\texttt{\^{}last(@2)} to get its oldest fact.

\subsection{Tables}\label{tables}

With the ability to create and manipulate facts comes the need to create
large numbers of them conveniently. This is the top-level declaration of
a table, a combination of a transient output macro declaration and a
bunch of data to execute the macro on. Usually the macro creates facts.

The table has

\begin{itemize}
\tightlist
\item
  a name (ignored- just for your documentation convenience),
\item
  a list of arguments,
\item
  a bunch of script,
\item
  a \texttt{DATA:} separator,
\item
  and then the table data.
\end{itemize}

The data is line oriented.

Within a line there are no rules about whitespace; you can indent, tab,
use lots of spaces, etc. Each line should have as many elements as the
table has arguments.

The table ends with the end of file or a new top-level declaration.
E.g.,

\begin{verbatim}
Table: authors (^author ^work ^copyright)

^createfact(^author member ~author) # add to concept ~author
^createfact(^work member ~book) # add to concept ~book
^createfact(^work exemplar ^author) # author wrote this book
if (^copyright != *) { ^createfact(^copyright date ^work) }

Data:
"Mark Twain" "Huckleberry Finn" 1884
"Mark Twain" "Tom Sawyer" * # don't know the date
\end{verbatim}

For tables with really short data, you can choose to cheat on the
separate line concept, and separate your entries with
\texttt{\textbackslash{}n} , which is the equivalent.

\begin{verbatim}
DATA:
a 1 \n b 2 \n c 3 \n d 4 \n e 5 # values assigned to letters.
f 6 g 7
\end{verbatim}

Tables of only single values do not need a line separator. E.g,

\begin{verbatim}
table: mine(^arg)
DATA:
value1 value2 value3
value4 value5 value6
\end{verbatim}

A table allows you to automatically list shortened synonyms of proper
names. For example, Paris could be a shortened synonym for \emph{Paris,
France}.

In a table of capitals, you would normally make the fact on the full
name, and write the shortened synonyms in parens. You may have more than
one: \emph{``Paris, France'' (Paris ``City of Love'') France}.

These synonyms are represented using the member verb, sort of like
making a concept set of the full name. The system detects this specially
during inferencing, and if an argument to \^{}query were \emph{Paris},
it could automatically transfer across and consider facts for
*Paris,\_France* as well.

It would not go the other way, however, so if the argument were
\emph{Paris\_France}, it would not move over to \emph{Paris}.

You should store your facts on the full name. The mechanism allows user
input to use the short name.

NOTE: Tables are executed (built) at compile time. And their resulting
data and variables are saved in the TOPIC folder along with your
compiled scripts and loaded when the server starts up. The data is
``owned'' by the server and not written out to user files. Also,
normally you cannot alter table data on the fly from a user script
interaction (true of all facts, not just table facts). In the event you
are compiling multiple bots at once, the facts of the table are owned by
whatever bot is considered to be compiling that chunk of code.

\subsection{Variable Argument Tables}\label{variable-argument-tables}

While a line of table data must fill all fields of the table exactly (no
more or less), you can tell the system to fill in the remaining
arguments with \texttt{*} by putting \texttt{\ldots{}} as your last
value. Eg.

\begin{verbatim}
table: test(^item1 ^item2 ^item3 ^item4)
# ...
Data:
lion 50 …
\end{verbatim}

This table will use \texttt{*} for item3 and item4 of lion.

Alternatively, you can declare the table variable via:

\begin{verbatim}
table: ^mytable variable ( ^arg1 ^arg2 ^arg3 ^arg4 )
\end{verbatim}

which allows you to not supply all arguments and not use
\texttt{\ldots{}}, but it means you get no error checking if you failed
to supply enough arguments.

Note:If you create member facts to add something to a concept, the
concept must have been predeclared. You can declare an empty concept
just before the table like this:

\begin{verbatim}
concept: ~newconcept()

table: mytable( ^x )
createfact(^x member ~newconcept)
DATA:
# data here
\end{verbatim}

\subsection{TABLEMACRO}\label{tablemacro}

When you have tables you generate over and over again, you don't want to
repeat all the script for it. Instead you want to declare a permanent
table function using a table macro.

It looks a lot like a table definition, except it has a different
declaration header and has no \texttt{DATA:} or data attached.

\begin{verbatim}
tablemacro: ^secondkeys(^topic ^key)
$$tmp = join(^topic . 1 )
CreateFact(^key member $$tmp)
\end{verbatim}

The table macro can declares more arguments than the table will have.
When you invoke an actual table using it, you will be supplying some of
the arguments then, and the rest come from the table data. An invocation
of this tablemacro would look like this:

\begin{verbatim}
table: ^secondkeys(~accidents)
repair garage insurance injure injury
\end{verbatim}

Note several things. This is declared as a table. The system can tell
the difference because the table name \texttt{(\^{}secondkeys)} will
already have a definition.

The arguments you supply must be real arguments, not \texttt{\^{}xxx}
names of dummy arguments). This table presupplies one argument
\texttt{(\textasciitilde{}accidents)}.

There is no need for a \texttt{DATA:} line because the table function
has already been defined- it knows all its code. So one proceeds
directly to supplying table data. In this instance, the code will be
expecting each table entry is one value, because the
\texttt{\^{}secondkeys} tablemacro said there are two arguments. Since
one is presupplied, the table data must supply the rest (1). So this
will execute the table code on each of the 5 table data entries.

\subsubsection{Datum}\label{datum}

You can use a tablemacro within a topic to declare a single table line.

It must be at the top level, like a \texttt{t:} or \texttt{u:} rule.
E.g.

\begin{verbatim}
topic: ~mytopic []
t: this is a test

datum: ^secondkeys(~accidents) repair
\end{verbatim}

Note that unlike tables that are allowed to run to many entries even on
the same line sometimes, a datum will only be allowed to run the
tablemacro once.

\subsection{TAB Tables}\label{tab-tables}

Normally each data line defines one entry of the table, filling in all
columns. But sometimes it's easier to read a vertically oriented table.
You can create them like this:

\begin{verbatim}
Location    Japan   Tokyo   
Location    Japan   Yokohama
\end{verbatim}

but that's crowded to read and excess typing. Another thing you can do
is:

\begin{verbatim}
Location    Japan   Tokyo   
*           *       Yokohama
\end{verbatim}

Where * means use the last seen value from prior entries (you write your
table to make that interpretation). Still it's tedious to put in the
well mannered \emph{. So there is one other thing you can do. You can
make a tab table, where tab characters are automatically convered into
space-separated } values instead of being ignored white space.

\begin{verbatim}
table: ^mytable TAB ($_arg1 $_arg2 $_arg3 )
DATA:
Location
    Japan   
        Tokyo   
        Yokohama
\end{verbatim}

is one such table. Looks a lot cleaner. Just be certain you are using
tabs and not spaces. You can write self-checking code in your table to
confirm users didn't screw up. The system variable \%tableinput shows
the actual line seen by the table function at each entry.

\subsection{String processing in
Tables}\label{string-processing-in-tables}

It is common for a string to be a table argument. Any functional string
\texttt{\^{}"xxx"} stores itself in an appropriate manner.

They are like regular output - they are literally output script.
Formatting is automatic and you get to make them do any kind of
executable thing, as though you were staring at actual output script.

There is no user context when compiling a table. As a consequence, if
you have table code that looks like this:

\begin{verbatim}
^createfact( x y ^" This is $var output")
\end{verbatim}

the functional string does NOT evaluate itself before going to
createfact. It gets stored as its original self.

Regular strings, by default, remove their quotes and substitute
underscores for spaces. This is good when the intention is as a
composite word, but if the string is to be used as direct output, you
may prefer to retain the quotes and spaces. You can do this by declaring
the argument name with \texttt{.KEEP\_QUOTES}. E.g.

\begin{verbatim}
table: ^test( ^my1 ^my2.KEEP_QUOTES)
\end{verbatim}

It is particularly important to use the quoted form when the contents
includes a concept or topic name that has underscores because the system
cannot tell a spacing underscore from a significant one.

\subsection{Simple Fact Functions (more in system functions
manual)}\label{simple-fact-functions-more-in-system-functions-manual}

Various functions create, destroy and aggregate facts, as well as mark
and unmark them. For those routines that aggregate facts, the result is
stored into a fact set. Usually this is done by assignment, e.g.

\begin{verbatim}
@2 = gambitTopics()
\end{verbatim}

Such assignments never fail, they just may assign a zero length to the
result. Often, however, you can use the function to simultaneously store
and test. If not in an assignment context, the function will store
results into \texttt{@0} and fail if the result is no facts. Eg.

\begin{verbatim}
if ( gambitTopics() ) { first(@0object)}
\end{verbatim}

\subsubsection{\texorpdfstring{\texttt{\^{}addproperty}( set flag
)}{\^{}addproperty( set flag )}}\label{addproperty-set-flag}

Add this flag onto all facts in named set or onto words. If you just say

\begin{verbatim}
^addproperty(@9 USER_FLAG3) 
\end{verbatim}

then all facts get that flag on them. The predefined but meaningless to
the system fact flags are \texttt{User\_flag4}, \texttt{User\_flag3},
\texttt{User\_flag2}, \texttt{User\_flag1}.

If set has a field marker (like \texttt{@2subject}) then the property is
added to all values of that field of facts of that set, that is, a
dictionary word. The flags must come from \texttt{dictionarysystem.h}
and the set of property flags or system flags.

\subsubsection{\texorpdfstring{\texttt{\^{}conceptlist}( kind location
)}{\^{}conceptlist( kind location )}}\label{conceptlist-kind-location}

Generates a list of transient facts for the designated word position in
the sentence of the concepts (or topics or both) referenced by that
word, based on \emph{kind} being \texttt{CONCEPT} or \texttt{TOPIC} or
\texttt{BOTH}. Facts are
\texttt{(\textasciitilde{}concept\ \^{}conceptlist\ location)} where
location is the location in the sentence.

\begin{verbatim}
^conceptlist( CONCEPT 3 ) # absolute sentence word index
^conceptlist( TOPIC _3 ) # whereever _3 is bound
\end{verbatim}

Otherwise, if you don't use an assignment, it stores into set 0 and
fails if no facts are found. Any set already marked
\texttt{\^{}Addproperty(\textasciitilde{}setname\ NOCONCEPTLIST)} will
not be returned from \texttt{\^{}conceptlist}. Special preexisting lists
you might use the members of to exclude include:
\texttt{\textasciitilde{}pos} (all bits of word properties)
\texttt{\textasciitilde{}sys} (all bits of system proerties) and
\texttt{\textasciitilde{}role} (all role bits from pos-tagging).

If you omit the 2nd argument (\emph{location}), then it generates the
set of all such in the sentence, iterating over every one but only doing
the first found reference of some kind.

If you use \texttt{\^{}mark} to mark a position, both the word and all
triggered concepts will be reported via \texttt{\^{}conceptlist}. But if
the mark is a non-canonical word, mark does not do anything about the
canonical form, and so there may be no triggered concepts as well. (Best
to use a canonical word as mark).

\subsubsection{\texorpdfstring{\texttt{\^{}createfact}( subject verb
object flags
)}{\^{}createfact( subject verb object flags )}}\label{createfact-subject-verb-object-flags}

the arguments are a stream, so \emph{flags} is optional. Creates a fact
of the listed data if it doesn't exist (unless flags allows duplicates).
See system functions manual for a bit more on how createfact can process
data.

\subsubsection{\texorpdfstring{\texttt{\^{}delete}( \{ set, filename\}
)}{\^{}delete( \{ set, filename\} )}}\label{delete-set-filename}

erase all facts in this set. This is the same as
\texttt{\^{}addfactproperty(set\ FACTDEAD)}.

\^{}delete(filename) will delete that file.

\subsubsection{\texorpdfstring{\texttt{\^{}field}(fact
fieldname)}{\^{}field(fact fieldname)}}\label{fieldfact-fieldname}

given a reference to a fact, pull out a named field. If the fieldname is
in lower case and the field is a fact reference, you get that number. If
the fieldname starts uppercase, the system gives you the printout of
that fact. Eg for a fact:

\begin{verbatim}
$$f = createfact (I eat (he eats beer))
^field( $$f object) # returns a number (the fact index)
\end{verbatim}

and

\begin{verbatim}
^field($$f object) # returns (he eats beer)`
\end{verbatim}

\emph{fieldname} include: \texttt{subject}, \texttt{verb},
\texttt{object}, \texttt{flags}, \texttt{all} (spread onto 3 match
variables, \texttt{raw} (spread onto 3 match variables).

\texttt{all} just displays a human normal dictionary word, so if the
value were actually \texttt{plants\textasciitilde{}1} you'd get just
plants whereas raw would return what was actually there
\texttt{plants\textasciitilde{}1}.

You can also retrieve a field via \texttt{\$\$f.subject} or
\texttt{\$\$f.verb} or \texttt{\$\$f.object} or \texttt{\$\$f.flags}.

\subsubsection{\texorpdfstring{\texttt{\^{}find}( setname itemname
)}{\^{}find( setname itemname )}}\label{find-setname-itemname}

given a concept set, find the ordered position of the 2nd argument
within it. Output that index (0-based). Used, for example, to compare
two poker hands.

\subsubsection{\texorpdfstring{\texttt{\^{}first}( fact-set-annotated
)}{\^{}first( fact-set-annotated )}}\label{first-fact-set-annotated}

retrieve the first fact. You must qualify with what you want from it.
Retrieve means the fact is removed from the set.
\texttt{\^{}first(@0subject)} retrieves the subject field of the first
fact.

Other obvious qualifications are \texttt{verb}, \texttt{object},
\texttt{fact} (return the index of the fact itself), \texttt{all}
(spread all 3 fields onto a match variable triple, \texttt{raw} (like
all but all displays just a normal human-readable word like plant
whereas raw displays what was actually there, which might have been
plant\textasciitilde{}1).

\subsubsection{\texorpdfstring{\texttt{\^{}last}( fact-set-annotated
)}{\^{}last( fact-set-annotated )}}\label{last-fact-set-annotated}

retrieve the last fact - see \texttt{\^{}first} for a more complete
explanation.

\subsubsection{\texorpdfstring{\texttt{\^{}length}( word
)}{\^{}length( word )}}\label{length-word}

puts the length of the word into the output stream. If word is actually
a fact set reference (e.g., \texttt{@2} ), it returns the count of facts
in the set.

\subsubsection{\texorpdfstring{\texttt{\^{}next}( FACT
fact-set-annotated
)}{\^{}next( FACT fact-set-annotated )}}\label{next-fact-fact-set-annotated}

Allows you to walk a set w/o erasing anything. See \texttt{\^{}first}
for more complete description of annotation, the distinction between
next and \texttt{\^{}first} is that next does NOT remove the fact from
the set, but moves on to each fact in turn. You can reset a set with

\begin{verbatim}
^reset(@1)
\end{verbatim}

then loop thru it looking at the subject field with

\begin{verbatim}
loop() { _0 = next(FACT @1subject) }
\end{verbatim}

\subsubsection{\texorpdfstring{\texttt{\^{}pick}(
\texttt{\textasciitilde{}concept}
)}{\^{}pick( \textasciitilde{}concept )}}\label{pick-concept}

Retrieve a random member of the concept. Pick is also used with factsets
to pick a random fact (analogous to \texttt{\^{}first} with its more
complete description).

\subsubsection{\texorpdfstring{\texttt{\^{}reset}( fact-set
)}{\^{}reset( fact-set )}}\label{reset-fact-set}

Reset a fact set for browsing using \texttt{\^{}next}.

\subsubsection{\texorpdfstring{\texttt{\^{}query}( kind subject verb
object
)}{\^{}query( kind subject verb object )}}\label{query-kind-subject-verb-object-1}

See writeup earlier.

\subsubsection{\texorpdfstring{\texttt{\^{}sort}( set
)}{\^{}sort( set )}}\label{sort-set}

sort the set.

\subsubsection{\texorpdfstring{\texttt{\^{}unduplicate}( set
)}{\^{}unduplicate( set )}}\label{unduplicate-set}

Remove duplicate facts from this set. The destination set will be named
in an assignment statement like:

\begin{verbatim}
@1 = ^unduplicate(@0)
\end{verbatim}

\section{Facts vs Variables}\label{facts-vs-variables}

How are facts and variables different? Which should you use?

Facts are persistent.

If you don't create them explicitly as transient, they stay with the
user forever.

Variables that don't begin with \texttt{\$\$} are also persistent and
stay with the user forever.

There are no limits on the number of variables you can have (none that
you need be aware of) and variable names can be up to 999 characters
long.

The limits on user facts that can be saved are defined as a parameter
when CS is started up (default 100). You can create more facts, but it
will only save the most recent limit.

Facts are indexed by subject, verb, object, so you can query to find
one.

Variables you have to know the name of it (but it can be composed on the
fly). Facts use up more memory, but can be exported to arbitrary files
(and imported).

Facts can represent an array of values, with a field as index. But so
can variables with omposited naming.

So mostly it depends on whether you want to find information by
querying. You have implicit associations of facts by the values of the
subject, verb, and object fields. But you could create a variable name
of two of the fields of the fact, if the third field was really the
fact's ``value''.

\textbf{WARNING} When you get a reference to a fact, like:

\begin{verbatim}
$$tmp = ^first(@1fact)
\end{verbatim}

that value is a numeric index into fact space. It is ONLY valid during
the current volley. You cannot insure that it will remain valid across
volleys. The valid ways to access facts across volleys are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  rerun \texttt{\^{}query(...)} to get a set of factsubject
\item
  get your fact reference into an @factset and have the set marked to
  save across volleys via \texttt{\^{}enable(write\ @4)}
\item
  save the fact as text to a permanet variable, e.g.,

\begin{verbatim}
$fact = ^WriteFact(^first(@1fact)
\end{verbatim}
\end{enumerate}

You can later reaccess (or recreate) this fact via
\texttt{\^{}createfact(\$fact)}.

\section{ADVANCED FACTS}\label{advanced-facts}

\subsection{Facts of Facts}\label{facts-of-facts}

Suppose you do something like

\begin{verbatim}
^createfact( john eat (wet food peanuts))
\end{verbatim}

What happens when you retrieve it into a fact set and then do

\begin{verbatim}
 _1 = ^last(@1+)
 
\end{verbatim}

and get the fact disassembled onto \texttt{\_1}, \texttt{\_2},
\texttt{\_3}, and \texttt{\_4}?

What you get for \texttt{\_3} is a reference to a fact, that is, a
number.

You can decode that by using \texttt{\^{}field(\ \_3\ subject)} or
\texttt{\^{}field(\_3\ verb)} or \texttt{\^{}fact(\_3\ object)} to get
wet or food or peanuts. The first argument to \texttt{\^{}field} is a
fact number.

You get a fact number if you do \texttt{\_3\ =\ createfact(...)} and can
decode \texttt{\_3} the same way. Naturally this function fails if you
give it something that cannot be a fact reference.

\subsection{Flags}\label{flags}

Facts may have flags on them. You can create them with flags (see
\texttt{\^{}createfact}) and you can get them using \^{}field or when
you spread out a fact onto a collection of match variables.

System-defined flags (which should not be set or erased by user scripts)
are:

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.21\columnwidth}\raggedright\strut
flag\strut
\end{minipage} & \begin{minipage}[b]{0.44\columnwidth}\raggedright\strut
description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{FACTSUBJECT}\texttt{FACTVERB}\texttt{FACTOBJECT}\strut
\end{minipage} & \begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
describe that a field is a fact\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{FACTDEAD}\strut
\end{minipage} & \begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
indicates the fact has been killed and will go away at the end of
volley\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Flags you can use to define facts that have system meaning but may or
may not stay on them are:

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.21\columnwidth}\raggedright\strut
flag\strut
\end{minipage} & \begin{minipage}[b]{0.44\columnwidth}\raggedright\strut
description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{FACTDUPLICATE}\strut
\end{minipage} & \begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
allow multiple versions of the same fact\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{FACTTRANSIENT}\strut
\end{minipage} & \begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
the fact should die at the end of the volley if not in a fact set\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{ORIGINAL\_ONLY}\strut
\end{minipage} & \begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
a ``member'' fact defining a concept only uses the raw word\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Flags you can set for yourself include:

\begin{longtable}[]{@{}ll@{}}
\toprule
flag & description\tabularnewline
\midrule
\endhead
\texttt{USER\_FLAG1}\texttt{USER\_FLAG2}\texttt{USER\_FLAG3}\texttt{USER\_FLAG4}
& user defined\tabularnewline
\bottomrule
\end{longtable}

Facts created by JSON code have user markings also, renamed as

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.21\columnwidth}\raggedright\strut
flag\strut
\end{minipage} & \begin{minipage}[b]{0.44\columnwidth}\raggedright\strut
description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{JSON\_PRIMITIVE\_VALUE}\texttt{JSON\_STRING\_VALUE}\texttt{JSON\_ARRAY\_VALUE}\texttt{JSON\_OBJECT\_VALUE}\strut
\end{minipage} & \begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
which indicate what kind of value the object of the fact is.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\texttt{JSON\_ARRAY\_FACT}\texttt{JSON\_OBJECT\_FACT}\strut
\end{minipage} & \begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
which indicate what kind of value the subect of the fact is.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\subsection{JSON}\label{json}

Json is a great representation for creating and accessing complex fact
structures. See the \href{ChatScript-Json.md}{ChatScript JSON manual}
for more details.

\section{ESOTERIC FACTS}\label{esoteric-facts}

\subsection{Compiled Script Table
Arguments}\label{compiled-script-table-arguments}

You can specify that a table argument string is to be compiled as output
script. Normally it's standard word processing like all English phrases.
To compile it, you prefix the doublequoted string with the function
designator \texttt{\^{}}. E.g.,

\begin{verbatim}
DATA:
~books "this is normal" ^"[script a][script b] ^fail(TOPIC)"
\end{verbatim}

This acts like a typical string. You pass it around, store it as value
of variables or as a field of a fact. Like all other strings, it remains
itself whenever it is put into the output stream, EXCEPT if you pass it
into the \texttt{\^{}eval} function. Then it will actual get executed
So.

To use that argument effectively, you would get it out of the fact you
built and store it onto some variable (like \texttt{\_5} or
\texttt{\$value}) , and then \texttt{\^{}eval(\_5)} or
\texttt{\^{}eval(\$value)}.

\subsection{FactSet Remaps}\label{factset-remaps}

Factset names like \texttt{@1} are not mnemonic. You can ``rename'' them
as follows:

\begin{verbatim}
rename: @bettername @12
\end{verbatim}

in a script before any uses of \texttt{@bettername}, which now mean
\texttt{@12}. Then you can do:

\begin{verbatim}
$$tmp = @betternamesubject
\end{verbatim}

\subsection{Predefined queries}\label{predefined-queries}

\texttt{exact\_} - use the given arguments without expanding beyond
them. Most efficient when you know exactly what you want.

\texttt{exact\_svrange} - find facts given subject and verb, where
object is a number and must be in range (\textgreater{}= propogate
\textless{}= match) \texttt{exact\_vrange} find facts given verb, where
object must be number in range (\textgreater{}= propogate \textless{}=
match)

\begin{verbatim}
e.g. @0 = ^query(exact_vrange ? myverb ? -1 ? ? $_lowvalue $_highvalue)
\end{verbatim}

\texttt{direct\_} and \texttt{direct\_flag}

\texttt{up2set} - propogate upwards from subject to find the fact that
leads to object of which is a given concept

\begin{verbatim}
given: (soap member ~hygiene_items) and (~hygiene_item member ~personal_items) and (~personal_items member ~drugstore) and (~drugstore member ~storetypes)
given  ^query(up2set soap ? '~store_type 10 )   - ie, what kind of store sells soap
yields (~drugstore member ~storetypes) 
\end{verbatim}

\texttt{up2seta} - similar to up2set but you name the verb instead of
assuming member/is

\subsection{Defining your own queries}\label{defining-your-own-queries}

The query code wanders around facts to find those you want. But since
facts can represent anything, you may need to custom tailor the query
system, which itself is a mini-programming language. The full query
function is takes nine arguments and any arguments at the end you omit
default themselves.

All query kinds are defined in \texttt{LIVEDATA/queries.txt} and you can
add entries to that (or revise existing ones). The essential things a
query needs to be able to do is:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Start with existing words or facts
\item
  Find related words or facts
\item
  Mark newly found words or facts so you don't trip over them multiple
  times
\item
  Mark words or facts that you want to ignore or be treated as a
  successful find
\item
  Store found facts
\end{enumerate}

A query specification provides a name for the query and specifies what
operations to do with what arguments, in what order.

An essential notion is the ``tag''. As the system examines facts, it is
not going to compare the text strings of words with some goal. That
would be inefficient. Instead it looks to see if a word or a fact has a
particular ``tag'' on it.

Each word/fact can have a single tag id, drawn from a set of nine. The
tags ids are labeled \texttt{1} thru \texttt{9}.

Another essential notion is the field/value. One refers to fields of
facts or values of the incoming arguments, or direct values in the query
script.

Here are the codes involved:

\begin{longtable}[]{@{}ll@{}}
\toprule
code & meaning\tabularnewline
\midrule
\endhead
\texttt{s} & refers to the subject argument or the subject field of a
fact\tabularnewline
\texttt{v} & refers to the verb argument or the verb field of a
fact\tabularnewline
\texttt{o} & refers to the object argument or the object field of a
fact\tabularnewline
\texttt{p} & refers to the propagate argument\tabularnewline
\texttt{m} & refers to the match argument\tabularnewline
\texttt{\textasciitilde{}set} & use the explicitly named concept
set\tabularnewline
\texttt{\textquotesingle{}word} & use the explicitly named
word\tabularnewline
\texttt{@n} & use the named fact set\tabularnewline
\bottomrule
\end{longtable}

Each query has is composed of four segments. Each segment is separated
using a colon. Each segment is a series of actions, which typically
involve naming a tag, a field, and then the operation, and possibly
special arguments to the operation.

You can separate things in a segment with a period or an underscore, to
assist in visual clarity. Those characters are ignored. I always
separate actions by underscores. The period I use to mark the end of
literal values (\texttt{\textasciitilde{}sets} and
\texttt{\textquotesingle{}words}).

\subsection{EXAMPLE 1 - PARIS as
subject}\label{example-1---paris-as-subject}

Consider this example: we want to find facts about Paris. The system has
these facts:

\begin{verbatim}
(Paris exemplar France)
\end{verbatim}

and

\begin{verbatim}
(Paris member ~capital)
\end{verbatim}

Our query will be

\begin{verbatim}
^query(direct_s Paris ? ?)
\end{verbatim}

which request all facts about a subject named \emph{Paris} (to be stored
in the default output factset \texttt{@0}).

Segment one handles marking and/or storing initial values. You always
start by naming the tag you want to use, then naming the field/value and
the operation.

The operations are:

\begin{longtable}[]{@{}ll@{}}
\toprule
operation & meaning\tabularnewline
\midrule
\endhead
\texttt{t} & tag the item\tabularnewline
\texttt{q} & tag and queue the item\tabularnewline
\texttt{\textless{}}\texttt{\textgreater{}} & scan from the item,
tagging things found (more explanation shortly)\tabularnewline
\bottomrule
\end{longtable}

The query \texttt{direct\_s}, which finds facts that have a given
subject, is defined as \texttt{1sq:s::}

This says segment 1 is \texttt{1sq} and segment 2 is \texttt{s} and
segments 3 and 4 have no data.

Segment 1 says to start with a tag of \texttt{1}, use the subject
argument and tag and queue it.

Segment two says how to use the queue. The queue is a list of words or
facts that will be used to find facts. In our example, having stored the
word \emph{Paris} onto the queue, we now get all facts in which
\emph{Paris} participates as the subject ( the s: segment )

Segment three tells how to disqualify facts that are found (deciding not
to return them). There is no code here, so all facts found will be
acceptable.

Segment four tells how to take disqualified facts as a source of further
navigation around the fact space. There is nothing here either.
Therefore the system returns the two facts with \emph{Paris} as the
subject

\subsection{Example 2 - Finding facts up in the
hierarchy}\label{example-2---finding-facts-up-in-the-hierarchy}

Assume you have this fact \texttt{(\ 23\ doyou\ \textasciitilde{}like)}
and what you actually have is a specific verb like which is a member of
\textasciitilde{}like. You want to find facts using doyou and like and
find facts where doyou matches and some set that contains like matches.

The query for this is \texttt{direct\_v\textless{}o}, which means you
have a verb and you have an object but you want the object to match
anywhere up in the hierarchy. \texttt{\textless{}}, which means the
start of the sentence in patterns, really means the left side of
something. And in the case of facts and concepts, the left side is the
more specific (lower in the hierarchy) and the right side is most
general (higher in the higherarchy) when the verb is member.

\end{document}
